{"version":3,"file":"simple-runtypes.cjs.development.js","sources":["../src/runtypeError.ts","../src/runtype.ts","../src/custom.ts","../src/any.ts","../src/boolean.ts","../src/enum.ts","../src/null.ts","../src/number.ts","../src/object.ts","../src/string.ts","../src/undefined.ts","../src/unknown.ts","../src/literal.ts","../src/stringLiteralUnion.ts","../src/guardedBy.ts","../src/ignore.ts","../src/integer.ts","../src/nullOr.ts","../src/undefinedOr.ts","../src/optional.ts","../src/stringAsInteger.ts","../src/json.ts","../src/array.ts","../src/tuple.ts","../src/record.ts","../src/dictionary.ts","../src/union.ts","../src/intersection.ts","../src/omit.ts","../src/partial.ts","../src/pick.ts"],"sourcesContent":["import { RuntypeError, Fail } from './runtype'\n\ntype RuntypeErrorInfo = RuntypeError | Fail\n\n/**\n * Turn an arbitrary object into a string of max length suitable for logging.\n */\nexport function debugValue(v: unknown, maxLength = 512): string {\n  let s: string\n\n  if (v === undefined) {\n    return 'undefined'\n  }\n\n  // `JSON.stringify(fn)` would return `undefined` thus `s.length` would become\n  // `undefined.length` which would fail\n  if (typeof v === 'function') {\n    return v.toString()\n  }\n\n  try {\n    s = JSON.stringify(v)\n  } catch {\n    s = `${v}`\n  }\n\n  if (s.length > maxLength) {\n    return s.slice(0, maxLength - 1) + '\\u2026'\n  } else {\n    return s\n  }\n}\n\n/**\n * Return boolean to indicate whether passed object seems to be an RuntypeError\n */\nfunction isRuntypeErrorPath(e: RuntypeErrorInfo): boolean {\n  return Array.isArray(e.path)\n}\n\n/**\n * Return the object path at which the error occured.\n */\nexport function getFormattedErrorPath(e: RuntypeErrorInfo): string {\n  if (!isRuntypeErrorPath(e)) {\n    return '(error is not a RuntypeError!)'\n  }\n\n  // path in Fail objects is with the root-element at the end bc. its easier\n  // to build it that way (just an [].push)\n  const pathInRootElementFirstOrder = [...e.path].reverse()\n\n  const formattedErrorPath = pathInRootElementFirstOrder\n    .map((k) =>\n      typeof k === 'number'\n        ? `[${k}]`\n        : /^\\w+$/.test(k)\n        ? `.${k}`\n        : `['${JSON.stringify(k)}']`,\n    )\n    .join('')\n\n  return formattedErrorPath.startsWith('.')\n    ? formattedErrorPath.slice(1)\n    : formattedErrorPath\n}\n\n/**\n * Return a string representaiton of the value that failed the runtype check.\n *\n * Cap the size of the returned string at maxLength\n */\nexport function getFormattedErrorValue(\n  e: RuntypeErrorInfo,\n  maxLength = 512,\n): string {\n  if (!isRuntypeErrorPath(e)) {\n    return '(error is not a RuntypeError!)'\n  }\n\n  const { value: resolvedValue } = e.path.reduceRight(\n    ({ value, isResolvable }, key) => {\n      // we have not not been able to resolve the value previously - don't try any further\n      if (!isResolvable) {\n        return { value, isResolvable }\n      }\n\n      // try to resolve key within objects or arrays\n      if (key in value) {\n        return { value: value[key], isResolvable }\n      }\n\n      // otherwise return last value successfully resolved and mark as \"not further resolvable\"\n      return { value, isResolvable: false }\n    },\n    { value: e.value, isResolvable: true },\n  )\n\n  return debugValue(resolvedValue, maxLength)\n}\n\n/**\n * Return a string representation of the value that failed the runtype check.\n *\n * Cap the size of the returned string at maxLength\n */\nexport function getFormattedError(\n  e: RuntypeErrorInfo,\n  maxLength = 512,\n): string {\n  const rawPath = getFormattedErrorPath(e)\n  const path = rawPath\n    ? `<value>${rawPath.startsWith('[') ? '' : '.'}${rawPath}`\n    : '<value>'\n  const label = 'name' in e ? `${e.name}: ` : ''\n  const value = getFormattedErrorValue(e, maxLength)\n\n  return `${label}${e.reason} at \\`${path}\\` for \\`${value}\\``\n}\n","/**\n * Thrown if the input does not match the runtype.\n *\n * Use `getFormattedErrorPath`, `getFormattedErrorValue` and\n * `getFormattedError` to convert path and value to a loggable string.\n */\nexport class RuntypeError extends Error {\n  // implements RuntypeErrorInfo\n  readonly path: (string | number)[]\n  readonly value: any\n  readonly reason: string\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(reason: string, value: any, path: (string | number)[]) {\n    super(reason)\n\n    this.name = 'RuntypeError'\n    this.reason = reason\n    this.path = path\n    this.value = value\n  }\n}\n\n/**\n * Thrown if the api is misused.\n */\nexport class RuntypeUsageError extends Error {}\n\n/**\n * Symbol that identifies failed typechecks\n */\nexport const failSymbol: unique symbol = Symbol('SimpleRuntypesFail')\n\n/**\n * Object to return internally if a typecheck failed\n *\n * This is used internally to avoid creating garbage for each runtype\n * validation call.\n */\nexport interface Fail {\n  [failSymbol]: true // marker to be able to distinguish Fail from other objects\n  reason: string\n  path: (string | number)[]\n  value?: any\n}\n\n// create a fail or raise the error exception if the called runtype was on top\nexport function createFail(\n  failOrThrow: typeof failSymbol | undefined,\n  msg: string,\n  topLevelValue?: unknown,\n): any {\n  if (failOrThrow === undefined) {\n    // runtype check failed\n    throw new RuntypeError(msg, topLevelValue, [])\n  } else if (failOrThrow === failSymbol) {\n    // runtype check failed but it should not throw an exception bc its called\n    // internally e.g. as part of a union or because we want to add debug info\n    // while unrolling the stack\n    return {\n      [failSymbol]: true,\n      reason: msg,\n      path: [],\n      value: undefined,\n    }\n  } else {\n    throw new RuntypeUsageError(\n      `failOrThrow must be undefined or the failSymbol, not ${JSON.stringify(\n        failOrThrow,\n      )}`,\n    )\n  }\n}\n\n// pass the fail up to the caller or, if on top, raise the error exception\nexport function propagateFail(\n  failOrThrow: typeof failSymbol | undefined,\n  failObj: Fail,\n  topLevelValue?: unknown,\n  key?: string | number,\n): Fail {\n  if (key !== undefined) {\n    failObj.path.push(key)\n  }\n\n  if (failOrThrow === undefined) {\n    // runtype check failed\n    throw new RuntypeError(failObj.reason, topLevelValue, failObj.path)\n  } else if (failOrThrow === failSymbol) {\n    return failObj\n  } else {\n    throw new RuntypeUsageError(\n      `failOrThrow must be undefined or the failSymbol, not ${JSON.stringify(\n        failOrThrow,\n      )}`,\n    )\n  }\n}\n\n/**\n * Runtype\n *\n * Just a function. The returned value may be a copy of v, depending on the\n * runtypes implementation.\n */\nexport interface Runtype<T> {\n  /**\n   * A function to check that v 'conforms' to type T\n   *\n   * By default, Raises a RuntypeError if the check fails.\n   * With `useRuntype(runtype, value)` it will return a `ValidationResult` instead.\n   */\n  (v: unknown): T\n}\n\n/**\n * Special runtype for use in record definitions to mark optional keys.\n */\nexport interface OptionalRuntype<T> {\n  isOptionalRuntype: true\n  (v: unknown): T\n}\n\nexport type Unpack<T> = T extends Runtype<infer U>\n  ? U\n  : T extends OptionalRuntype<infer V>\n  ? V\n  : never\n\n// force Typescript to boil down complex mapped types to a plain interface\nexport type Collapse<T> = T extends infer U ? { [K in keyof U]: U[K] } : never\n\nexport const isPureRuntypeSymbol = Symbol('isPure')\n\n// The internal runtype is one that receives an additional flag that\n// determines whether the runtype should throw a RuntypeError or whether it\n// should return a Fail up to the caller.\n//\n// Use this to:\n//   * accumulate additional path data when unwinding a fail (propagateFail)\n//   * have runtypes return a dedicated fail value to implement union over any\n//     runtypes (isFail)\n//\n// Pass `true` as isPure to signal that this runtype is not modifying its\n// value (checked with `isPureRuntype`\nexport function internalRuntype<T>(\n  fn: (v: unknown, failOrThrow?: typeof failSymbol) => T,\n  isPure?: boolean,\n): Runtype<T> {\n  if (isPure === true) {\n    return Object.assign(fn, { isPure: isPureRuntypeSymbol })\n  } else if (isPure === undefined || isPure === false) {\n    return fn\n  } else {\n    throw new RuntypeUsageError(\n      'expected \"isPure\" or undefined as the second argument',\n    )\n  }\n}\n\n/**\n * A pure runtype does not change its value.\n *\n * A non-pure runtype may return a changed value.\n * This is used to get rid of redundant object copying\n */\nexport function isPureRuntype(fn: Runtype<any>): boolean {\n  return !!(fn as any).isPure\n}\n\nexport type InternalRuntype = (\n  v: unknown,\n  failOrThrow: typeof failSymbol | undefined,\n) => any\n\n/**\n * Check whether a returned value is a failure.\n */\nexport function isFail(v: unknown): v is Fail {\n  if (typeof v !== 'object' || !v) {\n    return false\n  }\n\n  return (v as any)[failSymbol]\n}\n","import {\n  createFail,\n  Fail,\n  failSymbol,\n  internalRuntype,\n  InternalRuntype,\n  isFail,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\n/**\n * Create a validation error for custom runtypes\n */\nexport function createError(msg: string): Fail {\n  return createFail(failSymbol, msg)\n}\n\n/**\n * Construct a custom runtype from a validation function.\n */\nexport function runtype<T>(fn: (v: unknown) => T | Fail): Runtype<T> {\n  return internalRuntype<any>((v, failOrThrow) => {\n    const res = fn(v)\n\n    if (isFail(res)) {\n      return propagateFail(failOrThrow, res, v)\n    }\n\n    return res\n  })\n}\n\n/**\n * Explicit validation result containing the wrapped result or error.\n */\nexport type ValidationResult<T> =\n  | { ok: true; result: T }\n  | { ok: false; error: Fail }\n\n/**\n * Execute a runtype but do not throw Errors\n *\n * Return a ValidationResult instead.\n * When its an Error, use `getFormattedError` on it to get a well formatted\n * message for logging or reporting.\n *\n * Useful when writing your own runtypes and when the bad performance of\n * exceptions and try-catch for error handling is of concern.\n */\nexport function use<T>(r: Runtype<T>, v: unknown): ValidationResult<T> {\n  const result = (r as InternalRuntype)(v, failSymbol)\n\n  if (isFail(result)) {\n    // we don't know who is using the result (passing error up the stack or\n    // consuming it with e.g. `st.getFormattedError`) so set the toplevel\n    // value (will be overwritten in case we're passed up anyways)\n    result.value = v\n\n    return { ok: false, error: result }\n  }\n\n  return { ok: true, result }\n}\n","import { Runtype, internalRuntype } from './runtype'\n\n/**\n * A value to check later.\n */\nexport function any(): Runtype<any> {\n  return internalRuntype((v) => {\n    return v as any\n  }, true)\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\nconst booleanRuntype = internalRuntype<boolean>((v, failOrThrow) => {\n  if (v === true || v === false) {\n    return v\n  }\n\n  return createFail(failOrThrow, 'expected a boolean', v)\n}, true)\n\n/**\n * A boolean.\n */\nexport function boolean(): Runtype<boolean> {\n  return booleanRuntype\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\nimport { debugValue } from './runtypeError'\n\ntype EnumObject = { [key: string]: string | number }\n\n/**\n * Any value defined in the enumObject.\n */\nfunction enumRuntype<T extends EnumObject, S extends keyof T>(\n  enumObject: T,\n): Runtype<T[S]> {\n  return internalRuntype((v, failOrThrow) => {\n    // use the fast reverse lookup of number enums to check whether v is a\n    // value of the enum\n    if (typeof v === 'number' && (enumObject as any)[v as any] !== undefined) {\n      return (v as unknown) as T[S]\n    }\n\n    if (Object.values(enumObject).indexOf(v as any) !== -1) {\n      return v as T[S]\n    }\n\n    return createFail(\n      failOrThrow,\n      `expected a value that belongs to the enum ${debugValue(enumObject)}`,\n      v,\n    )\n  }, true)\n}\n\nexport { enumRuntype as enum }\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * null\n */\n// eslint-disable-next-line no-shadow-restricted-names\nfunction nullRuntype(): Runtype<null> {\n  return internalRuntype<null>((v, failOrThrow) => {\n    if (v !== null) {\n      return createFail(failOrThrow, 'expected null', v)\n    }\n\n    return v\n  }, true)\n}\n\nexport { nullRuntype as null }\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * A number. By default reject NaN and Infinity values.\n *\n * Options:\n *\n *   allowNaN .. allow NaN values\n *   allowInfinity .. allow positive and negative Infinity values\n *   min .. reject numbers smaller than that\n *   max .. reject numbers larger than that\n */\nexport function number(options?: {\n  allowNaN?: boolean\n  allowInfinity?: boolean\n  min?: number\n  max?: number\n}): Runtype<number> {\n  const { allowNaN, allowInfinity, min, max } = options || {}\n\n  return internalRuntype<number>((v, failOrThrow) => {\n    if (typeof v !== 'number') {\n      return createFail(failOrThrow, 'expected a number', v)\n    }\n\n    if (!allowNaN && isNaN(v)) {\n      return createFail(failOrThrow, 'expected a number that is not NaN', v)\n    }\n\n    if (!allowInfinity && (v === Infinity || v === -Infinity)) {\n      return createFail(failOrThrow, 'expected a finite number', v)\n    }\n\n    if (min !== undefined && v < min) {\n      return createFail(failOrThrow, `expected number to be >= ${min}`, v)\n    }\n\n    if (max !== undefined && v > max) {\n      return createFail(failOrThrow, `expected number to be <= ${max}`, v)\n    }\n\n    return v\n  }, true)\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n// cached object runtype\nexport const objectRuntype = internalRuntype<object>((v, failOrThrow) => {\n  if (typeof v === 'object' && !Array.isArray(v) && v !== null) {\n    return v\n  }\n\n  return createFail(failOrThrow, 'expected an object', v)\n}, true)\n\n/**\n * An object that is not an array.\n */\nexport function object(): Runtype<object> {\n  return objectRuntype\n}\n","import {\n  createFail,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\nconst stringRuntype = internalRuntype<string>((v, failOrThrow) => {\n  if (typeof v === 'string') {\n    return v\n  }\n\n  return createFail(failOrThrow, 'expected a string', v)\n}, true)\n\n/**\n * A string.\n *\n * Options:\n *\n *   minLength .. reject strings that are shorter than that\n *   maxLength .. reject strings that are longer than that\n *   trim .. when true, remove leading and trailing spaces from the string\n *   match .. reject strings that do not match against provided RegExp\n */\nexport function string(options?: {\n  minLength?: number\n  maxLength?: number\n  trim?: boolean\n  match?: RegExp\n}): Runtype<string> {\n  if (!options) {\n    return stringRuntype\n  }\n\n  const { minLength, maxLength, trim, match } = options\n\n  const isPure = !trim // trim modifies the string\n\n  return internalRuntype((v, failOrThrow) => {\n    const s: string = (stringRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(s)) {\n      return propagateFail(failOrThrow, s, v)\n    }\n\n    if (minLength !== undefined && s.length < minLength) {\n      return createFail(\n        failOrThrow,\n        `expected the string length to be at least ${minLength}`,\n        v,\n      )\n    }\n\n    if (maxLength !== undefined && s.length > maxLength) {\n      return createFail(\n        failOrThrow,\n        `expected the string length to not exceed ${maxLength}`,\n        v,\n      )\n    }\n\n    if (match !== undefined && !match.test(s)) {\n      return createFail(failOrThrow, `expected the string to match ${match}`, v)\n    }\n\n    return trim ? s.trim() : s\n  }, isPure)\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * undefined\n */\n// eslint-disable-next-line no-shadow-restricted-names\nfunction undefinedRuntype(): Runtype<undefined> {\n  return internalRuntype<undefined>((v, failOrThrow) => {\n    if (v !== undefined) {\n      return createFail(failOrThrow, 'expected undefined', v)\n    }\n\n    return v\n  }, true)\n}\n\nexport { undefinedRuntype as undefined }\n","import { internalRuntype, Runtype } from './runtype'\n\n/**\n * A value to check later.\n */\nexport function unknown(): Runtype<unknown> {\n  return internalRuntype((v) => {\n    return v\n  }, true)\n}\n","import { debugValue } from './runtypeError'\nimport { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * A literal string, number, boolean or enum.\n */\nexport function literal<T extends string>(lit: T): Runtype<T>\nexport function literal<T extends number>(lit: T): Runtype<T>\nexport function literal<T extends boolean>(lit: T): Runtype<T>\nexport function literal(lit: string | number | boolean): Runtype<any> {\n  const rt: any = internalRuntype((v, failOrThrow) => {\n    if (v === lit) {\n      return lit\n    }\n\n    return createFail(failOrThrow, `expected a literal: ${debugValue(lit)}`, v)\n  }, true)\n\n  // keep the literal as metadata on the runtype itself to be able to use it\n  // in record intersections to determine the right record runtype\n  rt.literal = lit\n\n  return rt\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * A union of string literals.\n */\nexport function stringLiteralUnion<V extends string[]>(\n  ...values: V\n): Runtype<V[number]> {\n  const valuesIndex = new Set(values)\n\n  return internalRuntype((v, failOrThrow) => {\n    if (typeof v !== 'string' || !valuesIndex.has(v)) {\n      return createFail(failOrThrow, `expected one of ${values}`, v)\n    }\n\n    return v\n  }, true)\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * A runtype based on a type guard\n */\nexport function guardedBy<F>(typeGuard: (v: unknown) => v is F): Runtype<F> {\n  return internalRuntype((v, failOrThrow) => {\n    if (!typeGuard(v)) {\n      return createFail(failOrThrow, 'expected typeguard to return true', v)\n    }\n\n    return v\n  }, true)\n}\n","import { internalRuntype, Runtype } from './runtype'\n\n/**\n * A value to ignore (typed as unknown and always set to undefined).\n */\nexport function ignore(): Runtype<unknown> {\n  return internalRuntype(() => {\n    return undefined as unknown\n  }, true)\n}\n","import {\n  createFail,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\nexport const integerRuntype = internalRuntype<number>((v, failOrThrow) => {\n  if (typeof v === 'number' && Number.isSafeInteger(v)) {\n    return v\n  }\n\n  return createFail(failOrThrow, 'expected a safe integer', v)\n}, true)\n\n/**\n * A Number that is a `isSafeInteger()`\n *\n * Options:\n *\n *   min .. reject numbers smaller than that\n *   max .. reject number larger than that\n */\nexport function integer(options?: {\n  max?: number\n  min?: number\n}): Runtype<number> {\n  if (!options) {\n    return integerRuntype\n  }\n\n  const { min, max } = options\n\n  return internalRuntype<number>((v, failOrThrow) => {\n    const n = (integerRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(n)) {\n      return propagateFail(failOrThrow, n, v)\n    }\n\n    if (min !== undefined && n < min) {\n      return createFail(failOrThrow, `expected the integer to be >= ${min}`, v)\n    }\n\n    if (max !== undefined && n > max) {\n      return createFail(failOrThrow, `expected the integer to be <= ${max}`, v)\n    }\n\n    return n\n  }, true)\n}\n","import {\n  InternalRuntype,\n  internalRuntype,\n  isPureRuntype,\n  Runtype,\n} from './runtype'\n\n/**\n * Shortcut for a type or null.\n */\nexport function nullOr<A>(t: Runtype<A>): Runtype<A | null> {\n  const isPure = isPureRuntype(t)\n\n  return internalRuntype((v, failOrThrow) => {\n    if (v === null) {\n      return null\n    }\n\n    return (t as InternalRuntype)(v, failOrThrow)\n  }, isPure)\n}\n","import {\n  InternalRuntype,\n  internalRuntype,\n  isPureRuntype,\n  Runtype,\n} from './runtype'\n\n/**\n * Shortcut for a type or undefined.\n */\nexport function undefinedOr<A>(t: Runtype<A>): Runtype<A | undefined> {\n  const isPure = isPureRuntype(t)\n\n  return internalRuntype((v, failOrThrow) => {\n    if (v === undefined) {\n      return undefined\n    }\n\n    return (t as InternalRuntype)(v, failOrThrow)\n  }, isPure)\n}\n","import {\n  InternalRuntype,\n  internalRuntype,\n  isPureRuntype,\n  OptionalRuntype,\n  Runtype,\n} from './runtype'\n\n/**\n * Optional (?), only usable within `record`\n *\n * Marks the key its used on as optional, e.g.:\n *\n *    record({foo: optional(string())})\n *\n *    => {foo?: string}\n */\nexport function optional<A>(t: Runtype<A>): OptionalRuntype<A> {\n  const isPure = isPureRuntype(t)\n\n  const rt = internalRuntype((v, failOrThrow) => {\n    if (v === undefined) {\n      return undefined\n    }\n\n    return (t as InternalRuntype)(v, failOrThrow)\n  }, isPure) as OptionalRuntype<A>\n\n  return rt\n}\n","import { integerRuntype } from './integer'\nimport {\n  createFail,\n  failSymbol,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\nexport const stringAsIntegerRuntype = internalRuntype<number>(\n  (v, failOrThrow) => {\n    if (typeof v === 'string') {\n      const parsedNumber = parseInt(v, 10)\n      const n: number = (integerRuntype as InternalRuntype)(\n        parsedNumber,\n        failSymbol,\n      )\n\n      if (isFail(n)) {\n        return propagateFail(failOrThrow, n, v)\n      }\n\n      // ensure that value did only contain that integer, nothing else\n      // but also make '+1' === '1' and '-0' === '0'\n      const vStringSansLeadingPlus =\n        v === '-0' ? '0' : v[0] === '+' ? v.slice(1) : v\n\n      if (n.toString() !== vStringSansLeadingPlus) {\n        return createFail(\n          failOrThrow,\n          'expected string to contain only the safe integer, not additional characters, whitespace or leading zeros',\n          v,\n        )\n      }\n\n      return n\n    }\n\n    return createFail(\n      failOrThrow,\n      'expected a string that contains a safe integer',\n      v,\n    )\n  },\n)\n\n/**\n * A string that is parsed as an integer.\n *\n * Parsing is strict, e.g leading/trailing whitespace or leading zeros will\n * result in an error. Exponential notation is not allowed. The resulting\n * number must be a safe integer (`Number.isSafeInteger`).\n * A leading '+' or '-' is allowed.\n *\n * Options:\n *\n *   min .. reject numbers smaller than that\n *   max .. reject number larger than that\n */\nexport function stringAsInteger(options?: {\n  min?: number\n  max?: number\n}): Runtype<number> {\n  if (!options) {\n    return stringAsIntegerRuntype\n  }\n\n  const { min, max } = options\n\n  return internalRuntype<number>((v, failOrThrow) => {\n    const n = (stringAsIntegerRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(n)) {\n      return propagateFail(failOrThrow, n, v)\n    }\n\n    if (min !== undefined && n < min) {\n      return createFail(failOrThrow, `expected the integer to be >= ${min}`, v)\n    }\n\n    if (max !== undefined && n > max) {\n      return createFail(failOrThrow, `expected the integer to be <= ${max}`, v)\n    }\n\n    return n\n  })\n}\n","import {\n  createFail,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  propagateFail,\n  Runtype,\n} from './runtype'\nimport { use } from './custom'\n\nexport const jsonRuntype = internalRuntype<unknown>((v, failOrThrow) => {\n  if (!(typeof v === 'string')) {\n    return createFail(failOrThrow, 'expected a json string', v)\n  }\n\n  try {\n    const jsonData = JSON.parse(v)\n    return jsonData\n  } catch (err) {\n    return createFail(failOrThrow, 'expected a json string: ' + String(err), v)\n  }\n}, false)\n\n/**\n * A String that is valid json\n */\nexport function json<T>(rt: Runtype<T>): Runtype<T> {\n  return internalRuntype<any>((v, failOrThrow) => {\n    const n = (jsonRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(n)) {\n      return propagateFail(failOrThrow, n, v)\n    }\n\n    const validationResult = use(rt, n)\n\n    if (!validationResult.ok) {\n      return propagateFail(failOrThrow, validationResult.error, v)\n    }\n\n    return validationResult.result\n  }, false)\n}\n","import {\n  createFail,\n  failSymbol,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\nexport const arrayRuntype = internalRuntype<unknown[]>((v, failOrThrow) => {\n  if (Array.isArray(v)) {\n    return v\n  }\n\n  return createFail(failOrThrow, `expected an Array`, v)\n}, true)\n\n/**\n * An array of a given type.\n *\n * Options:\n *\n *   minLength .. reject arrays shorter than that\n *   maxLength .. reject arrays longer than that\n */\nexport function array<A>(\n  a: Runtype<A>,\n  options?: { maxLength?: number; minLength?: number },\n): Runtype<A[]> {\n  const { maxLength, minLength } = options || {}\n\n  const isPure = isPureRuntype(a)\n\n  return internalRuntype<any>((v, failOrThrow) => {\n    const arrayValue = (arrayRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(arrayValue)) {\n      return propagateFail(failOrThrow, arrayValue, v)\n    }\n\n    if (maxLength !== undefined && arrayValue.length > maxLength) {\n      return createFail(\n        failOrThrow,\n        `expected the array to contain at most ${maxLength} elements`,\n        v,\n      )\n    }\n\n    if (minLength !== undefined && arrayValue.length < minLength) {\n      return createFail(\n        failOrThrow,\n        `expected the array to contain at least ${minLength} elements`,\n        v,\n      )\n    }\n\n    // copy the unknown array in case the item runtype is not pure (we do not mutate anything in place)\n    const res: A[] = isPure ? arrayValue : new Array(arrayValue.length)\n\n    for (let i = 0; i < arrayValue.length; i++) {\n      const item = (a as InternalRuntype)(arrayValue[i], failSymbol)\n\n      if (isFail(item)) {\n        return propagateFail(failOrThrow, item, v, i)\n      }\n\n      if (!isPure) {\n        res[i] = item\n      }\n    }\n\n    return res\n  }, isPure)\n}\n","import {\n  createFail,\n  failSymbol,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\nimport { arrayRuntype } from './array'\n\n// TODO: find a simple (not type-computationally expensive) generic tuple definition.\n// atm the one that comes closest would be: https://github.com/Microsoft/TypeScript/issues/13298#issuecomment-675386981\n// For now, keep the tuple definition simple as I don't see a usecase for big\n// (>5elements) tuples. Most of the time I use them only for simple [lat, lon],\n// [x,y,z] and other vectors.\n/**\n * A tuple.\n */\nexport function tuple<A>(a: Runtype<A>): Runtype<[A]>\nexport function tuple<A, B>(a: Runtype<A>, b: Runtype<B>): Runtype<[A, B]>\nexport function tuple<A, B, C>(\n  a: Runtype<A>,\n  b: Runtype<B>,\n  c: Runtype<C>,\n): Runtype<[A, B, C]>\nexport function tuple<A, B, C, D>(\n  a: Runtype<A>,\n  b: Runtype<B>,\n  c: Runtype<C>,\n  d: Runtype<D>,\n): Runtype<[A, B, C, D]>\nexport function tuple<A, B, C, D, E>(\n  a: Runtype<A>,\n  b: Runtype<B>,\n  c: Runtype<C>,\n  d: Runtype<D>,\n  e: Runtype<E>,\n): Runtype<[A, B, C, D, E]>\nexport function tuple(...types: Runtype<any>[]): Runtype<any> {\n  const isPure = types.every((t) => isPureRuntype(t))\n\n  return internalRuntype<any>((v, failOrThrow) => {\n    const a = (arrayRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(a)) {\n      return propagateFail(failOrThrow, a, v)\n    }\n\n    if (a.length !== types.length) {\n      return createFail(\n        failOrThrow,\n        'tuple array does not have the required length',\n        v,\n      )\n    }\n\n    const res: any[] = isPure ? a : new Array(a.length)\n\n    for (let i = 0; i < types.length; i++) {\n      const item = (types[i] as InternalRuntype)(a[i], failSymbol)\n\n      if (isFail(item)) {\n        return propagateFail(failOrThrow, item, v, i)\n      }\n\n      if (!isPure) {\n        res[i] = item\n      }\n    }\n\n    return res\n  }, isPure)\n}\n","import {\n  createFail,\n  failSymbol,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n  Runtype,\n  OptionalRuntype,\n  Collapse,\n  Unpack,\n} from './runtype'\nimport { debugValue } from './runtypeError'\n\nfunction isPureTypemap(typemap: object) {\n  for (const k in typemap) {\n    if (!Object.prototype.hasOwnProperty.call(typemap, k)) {\n      continue\n    }\n\n    if (!isPureRuntype(typemap[k as keyof typeof typemap])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction internalRecord(\n  typemap: { [key: string]: Runtype<any> | OptionalRuntype<any> },\n  sloppy: boolean,\n): Runtype<any> {\n  // a sloppy record may ignore keys and so cannot be pure\n  const isPure = !sloppy && isPureTypemap(typemap)\n\n  // cache typemap in arrays for a faster loop\n  const typemapKeys = [...Object.keys(typemap)]\n  const typemapValues = [...Object.values(typemap)]\n\n  const rt = internalRuntype((v, failOrThrow) => {\n    // inlined object runtype for perf\n    if (typeof v !== 'object' || Array.isArray(v) || v === null) {\n      return createFail(failOrThrow, 'expected an object', v)\n    }\n\n    const o: any = v\n\n    // optimize allocations: only create a copy if the record is impure\n    const res = isPure ? o : {}\n\n    for (let i = 0; i < typemapKeys.length; i++) {\n      const k = typemapKeys[i]\n      const t = typemapValues[i] as InternalRuntype\n\n      // nested types should always fail with explicit `Fail` so we can add additional data\n      const value = t(o[k], failSymbol)\n\n      if (isFail(value)) {\n        if (!(k in o)) {\n          // rt failed because o[k] was undefined bc. the key was missing from o\n          // use a more specific error message in this case\n          return createFail(\n            failOrThrow,\n            `missing key in record: ${debugValue(k)}`,\n          )\n        }\n\n        return propagateFail(failOrThrow, value, v, k)\n      }\n\n      if (!isPure) {\n        res[k] = value\n      }\n    }\n\n    if (!sloppy) {\n      const unknownKeys: string[] = []\n\n      for (const k in o) {\n        if (!Object.prototype.hasOwnProperty.call(typemap, k)) {\n          unknownKeys.push(o)\n        }\n      }\n\n      if (unknownKeys.length) {\n        return createFail(\n          failOrThrow,\n          `invalid keys in record ${debugValue(unknownKeys)}`,\n          v,\n        )\n      }\n    }\n\n    return res\n  }, isPure)\n\n  // fields metadata to implement combinators like (discriminated) unions,\n  // pick, omit and intersection\n  const fields: { [key: string]: any } = {}\n\n  for (const k in typemap) {\n    fields[k] = typemap[k]\n  }\n\n  // eslint-disable-next-line no-extra-semi\n  ;(rt as any).fields = fields\n\n  return rt\n}\n\nexport function getRecordFields(\n  r: Runtype<any>,\n): { [key: string]: Runtype<any> } | undefined {\n  const anyRt: any = r\n\n  if (!anyRt.fields) {\n    return\n  }\n\n  return anyRt.fields\n}\n\n/**\n * An object with defined keys and values.\n *\n * In contrast to typescript types, objects checked by this runtype will fail\n * if they have any additional keys (strict checking) not specified in\n * typemap.\n *\n * Keeps you save from unwanted propertiers and evil __proto__ injections.\n */\nexport function record<\n  T,\n  Typemap = { [K in keyof T]: Runtype<T[K]> | OptionalRuntype<T[K]> },\n  OptionalKeys extends keyof Typemap = {\n    [K in keyof Typemap]: Typemap[K] extends OptionalRuntype<any> ? K : never\n  }[keyof Typemap]\n>(\n  typemap: Typemap,\n): Runtype<\n  Collapse<\n    { [K in Exclude<keyof Typemap, OptionalKeys>]: Unpack<Typemap[K]> } &\n      { [K in OptionalKeys]?: Unpack<Typemap[K]> }\n  >\n> {\n  return internalRecord(typemap as any, false)\n}\n\n/**\n * Like record but ignore unknown keys.\n *\n * Returns a new object that only contains the keys specified in the typemap.\n * Additional keys are ignored.\n *\n * Keeps you save from unwanted propertiers and evil __proto__ injections.\n */\nexport function sloppyRecord<\n  T,\n  Typemap = { [K in keyof T]: Runtype<T[K]> | OptionalRuntype<T[K]> },\n  OptionalKeys extends keyof Typemap = {\n    [K in keyof Typemap]: Typemap[K] extends OptionalRuntype<any> ? K : never\n  }[keyof Typemap]\n>(\n  typemap: Typemap,\n): Runtype<\n  Collapse<\n    { [K in Exclude<keyof Typemap, OptionalKeys>]: Unpack<Typemap[K]> } &\n      { [K in OptionalKeys]?: Unpack<Typemap[K]> }\n  >\n> {\n  return internalRecord(typemap as any, true)\n}\n","import { objectRuntype } from './object'\nimport {\n  createFail,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n} from './runtype'\nimport { debugValue } from './runtypeError'\nimport type { Runtype, InternalRuntype, Fail } from './runtype'\n\nfunction dictionaryRuntype<T extends string, U>(\n  keyRuntype: Runtype<T>,\n  valueRuntype: Runtype<U>,\n) {\n  const isPure = isPureRuntype(keyRuntype) && isPureRuntype(valueRuntype)\n\n  return internalRuntype<Record<T, U>>((v, failOrThrow) => {\n    const o: object | Fail = (objectRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(o)) {\n      return propagateFail(failOrThrow, o, v)\n    }\n\n    if (Object.getOwnPropertySymbols(o).length) {\n      return createFail(\n        failOrThrow,\n        `invalid key in dictionary: ${debugValue(\n          Object.getOwnPropertySymbols(o),\n        )}`,\n        v,\n      )\n    }\n\n    // optimize allocations: only create a copy if any of the key runtypes\n    // return a different object - otherwise return value as is\n    const res = (isPure ? o : {}) as { [key: string]: U }\n\n    for (const key in o) {\n      if (!Object.prototype.hasOwnProperty.call(o, key)) {\n        continue\n      }\n\n      if (key === '__proto__') {\n        // e.g. someone tried to sneak __proto__ into this object and that\n        // will cause havoc when assigning it to a new object (in case its impure)\n        return createFail(\n          failOrThrow,\n          `invalid key in dictionary: ${debugValue(key)}`,\n          v,\n        )\n      }\n      const keyOrFail: T | Fail = (keyRuntype as InternalRuntype)(\n        key,\n        failOrThrow,\n      )\n\n      if (isFail(keyOrFail)) {\n        return propagateFail(failOrThrow, keyOrFail, v)\n      }\n\n      const value = o[key as keyof typeof o]\n      const valueOrFail: U | Fail = (valueRuntype as InternalRuntype)(\n        value,\n        failOrThrow,\n      )\n\n      if (isFail(valueOrFail)) {\n        return propagateFail(failOrThrow, valueOrFail, v)\n      }\n\n      if (!isPure) {\n        res[keyOrFail] = valueOrFail\n      }\n    }\n\n    return res\n  }, isPure)\n}\n\n/**\n * An object that matches a Typecript `Record<KeyType, ValueType>` type.\n *\n * You pass a runtype for the objects keys and one for its values.\n * Keeps you save from unwanted propertiers and evil __proto__ injections.\n */\nexport function dictionary<T extends Runtype<any>, U extends Runtype<any>>(\n  keyRuntype: T,\n  valueRuntype: U,\n): Runtype<Record<ReturnType<T>, ReturnType<U>>> {\n  return dictionaryRuntype(keyRuntype, valueRuntype)\n}\n","import { objectRuntype } from './object'\nimport { getRecordFields } from './record'\nimport {\n  createFail,\n  Fail,\n  failSymbol,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n  Runtype,\n  RuntypeUsageError,\n} from './runtype'\nimport { debugValue } from './runtypeError'\n\n// A tagged union with type discriminant 'key'.\n// Runtypes must be created with `record(...)` which contains type metadata to\n// identify the literals in each record.\n// Perform an efficient lookup of runtype functions by checking the\n// discriminant key and using the runtype that matches it. This results 1\n// runtype check vs man in the naive union check implementation.\nfunction internalDiscriminatedUnion(\n  key: string,\n  runtypes: Runtype<any>[],\n): Runtype<any> {\n  const typeMap = new Map<string | number, Runtype<any>>()\n\n  // build an index for fast runtype lookups by literal\n  runtypes.forEach((t: any) => {\n    const rt = t.fields[key]\n    const tagValue = rt.literal\n\n    if (tagValue === undefined) {\n      throw new RuntypeUsageError(\n        `broken record type definition, ${t}[${key}] is not a literal`,\n      )\n    }\n\n    if (!(typeof tagValue === 'string' || typeof tagValue === 'number')) {\n      throw new RuntypeUsageError(\n        `broken record type definition, ${t}[${key}] must be a string or number, not ${debugValue(\n          tagValue,\n        )}`,\n      )\n    }\n\n    // use `object` to also allow enums but they can't be used in types\n    // for keys of indexes so we need any\n    typeMap.set(tagValue, t)\n  })\n\n  const isPure = runtypes.every((t) => isPureRuntype(t))\n\n  const resultingRuntype = internalRuntype((v, failOrThrow) => {\n    const o: any = (objectRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(o)) {\n      return propagateFail(failOrThrow, o, v)\n    }\n\n    const tagValue = o[key]\n    const rt = typeMap.get(tagValue)\n\n    if (rt === undefined) {\n      return createFail(\n        failOrThrow,\n        `no Runtype found for discriminated union tag ${key}: ${debugValue(\n          tagValue,\n        )}`,\n        v,\n      )\n    }\n\n    return (rt as InternalRuntype)(v, failOrThrow)\n  }, isPure)\n\n  // keep the union runtypes around to implement combinators that need to distribute across unions like intersection\n  ;(resultingRuntype as any).unions = runtypes\n\n  return resultingRuntype\n}\n\n// given a list of runtypes, return the name of the key that acts as the\n// unique discriminating value across all runtypes\n// return undefined if no such key exists\nfunction findDiscriminatingUnionKey(\n  runtypes: Runtype<any>[],\n): string | undefined {\n  const commonKeys = new Map<string, Set<string>>()\n\n  for (let i = 0; i < runtypes.length; i++) {\n    const r = runtypes[i]\n    const fields = getRecordFields(r)\n\n    if (!fields) {\n      // not a record runtype -> no common tag key\n      return\n    }\n\n    for (const f in fields) {\n      const fieldRuntype = fields[f]\n      const l = (fieldRuntype as any).literal\n\n      if (l !== undefined) {\n        // found a literal value, add it to the field\n        // if we get a distinct literalruntype, we can use the optimized\n        // index-accessed internalDiscriminatedUnion runtype\n        if (!commonKeys.has(f)) {\n          commonKeys.set(f, new Set())\n        }\n\n        commonKeys.get(f)?.add(l)\n      }\n    }\n  }\n\n  const possibleKeys: string[] = []\n\n  commonKeys.forEach((val, key) => {\n    // when the key has a unique value for each runtype it can be used as a discriminant\n    if (val.size === runtypes.length) {\n      possibleKeys.push(key)\n    }\n  })\n\n  if (!possibleKeys.length) {\n    return\n  }\n\n  // just use the first key (any key in possibleKeys would suffice)\n  return possibleKeys[0]\n}\n\n// helper type to get the type of a runtype\ntype UnpackRuntypes<T extends Runtype<any>> = T extends Runtype<infer R>\n  ? R\n  : never\n\n/**\n * A union of runtypes.\n */\nexport function union<V extends Runtype<any>[]>(\n  ...runtypes: V\n): Runtype<UnpackRuntypes<V[number]>> {\n  if (!runtypes.length) {\n    throw new RuntypeUsageError('no runtypes given to union')\n  }\n\n  // optimize: when the union is a discriminating union, find the\n  // discriminating key and use it to look up the runtype for the keys value\n  const commonKey = findDiscriminatingUnionKey(runtypes)\n\n  if (commonKey !== undefined) {\n    return internalDiscriminatedUnion(commonKey, runtypes)\n  }\n\n  const isPure = runtypes.every((t) => isPureRuntype(t))\n\n  // simple union validation: try all runtypes and use the first one that\n  // doesn't fail\n  return internalRuntype((v, failOrThrow) => {\n    let lastFail: Fail | undefined\n\n    for (let i = 0; i < runtypes.length; i++) {\n      const val = (runtypes[i] as InternalRuntype)(v, failSymbol)\n\n      if (!isFail(val)) {\n        return val\n      } else {\n        lastFail = val\n      }\n    }\n\n    return propagateFail(failOrThrow, lastFail as any, v)\n  }, isPure)\n}\n","import { union } from './union'\nimport { record } from './record'\nimport {\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n  Runtype,\n  RuntypeUsageError,\n} from './runtype'\n\n// An intersection of two record runtypes\nfunction recordIntersection2<A, B>(\n  recordA: Runtype<A>,\n  recordB: Runtype<B>,\n): Runtype<A & B> {\n  const fields: { [key: string]: Runtype<any> } = {}\n  const a = (recordA as any).fields\n  const b = (recordB as any).fields\n\n  for (const k in { ...a, ...b }) {\n    if (a[k] && b[k]) {\n      fields[k] = intersection(a[k], b[k])\n    } else if (a[k]) {\n      fields[k] = a[k]\n    } else if (b[k]) {\n      fields[k] = b[k]\n    } else {\n      throw new RuntypeUsageError('recordIntersection2: invalid else')\n    }\n  }\n\n  // results in a new record type\n  return record<any>(fields)\n}\n\n// An intersection of a union with another type\nfunction unionIntersection2<A, B>(\n  u: Runtype<A>,\n  b: Runtype<B>,\n): Runtype<A & B> {\n  const unionRuntypes: Runtype<any>[] = (u as any).unions\n\n  if (\n    !unionRuntypes ||\n    !Array.isArray(unionRuntypes) ||\n    !unionRuntypes.length\n  ) {\n    throw new RuntypeUsageError(\n      'unionIntersection2: first argument is not a union type',\n    )\n  }\n\n  // results in a new union (because the intersection distributes over the union)\n  return union<Runtype<any>[]>(\n    ...unionRuntypes.map((a) => intersection2<any, any>(a, b)),\n  )\n}\n\n/**\n * An intersection of two runtypes.\n *\n * In case the intersection contains records or unions (of records), create a\n * completely new record or union runtype.\n */\nfunction intersection2<A, B>(a: Runtype<A>, b: Runtype<B>): Runtype<A & B>\nfunction intersection2(a: Runtype<any>, b: Runtype<any>): Runtype<any> {\n  if ('fields' in a && 'fields' in b) {\n    return recordIntersection2(a, b)\n  } else if ('unions' in a && 'fields' in b) {\n    return unionIntersection2(a, b)\n  } else if ('unions' in b && 'fields' in a) {\n    return unionIntersection2(b, a)\n  } else if ('fields' in a || 'fields' in b) {\n    // Does such an intersection (e.g. string | {a: number} even make sense?\n    // And how would you implement it?\n    throw new RuntypeUsageError(\n      'intersection2: cannot intersect a base type with a record',\n    )\n  } else {\n    const isPure = isPureRuntype(a) && isPureRuntype(b)\n\n    return internalRuntype((v, failOrThrow) => {\n      const valFromA = (a as InternalRuntype)(v, failOrThrow)\n      const valFromB = (b as InternalRuntype)(v, failOrThrow)\n\n      if (isFail(valFromB)) {\n        return propagateFail(failOrThrow, valFromB, v)\n      }\n\n      if (isFail(valFromA)) {\n        return propagateFail(failOrThrow, valFromA, v)\n      }\n\n      return valFromB // second runtype arg is preferred\n    }, isPure)\n  }\n}\n\n/**\n * An intersection of runtypes.\n */\nexport function intersection<A, B>(a: Runtype<A>, b: Runtype<B>): Runtype<A & B>\nexport function intersection<A, B, C>(\n  a: Runtype<A>,\n  b: Runtype<B>,\n  c: Runtype<C>,\n): Runtype<A & B & C>\nexport function intersection(...args: Runtype<any>[]): Runtype<any> {\n  if (args.length === 2) {\n    return intersection2(args[0], args[1])\n  } else if (args.length === 3) {\n    return intersection(intersection2(args[0], args[1]), args[2])\n  } else {\n    throw new RuntypeUsageError(\n      `unsupported number of arguments ${args.length}`,\n    )\n  }\n}\n","import { record } from './record'\nimport { Runtype, RuntypeUsageError } from './runtype'\n\n/**\n * Build a new record runtype that omits some keys from the original.\n */\n// TODO: should work with unions too!!!!!\nexport function omit<T, K extends keyof T>(\n  original: Runtype<T>,\n  ...keys: K[]\n): Runtype<Omit<T, K>> {\n  const fields = (original as any).fields\n\n  if (!fields) {\n    throw new RuntypeUsageError(`expected a record runtype`)\n  }\n\n  const newRecordFields: any = { ...fields }\n\n  keys.forEach((k: any) => {\n    delete newRecordFields[k]\n  })\n\n  // TODO: keep 'sloppyness'\n  return record(newRecordFields) as Runtype<any>\n}\n","import { optional } from './optional'\nimport { record } from './record'\nimport { Runtype, RuntypeUsageError } from './runtype'\n\n/**\n * Build a new record runtype that marks all keys as optional.\n *\n * This is the runtype counterpart to `Partial<T>`.\n */\nexport function partial<T, K extends keyof T>(\n  original: Runtype<T>,\n): Runtype<Partial<T>> {\n  const fields = (original as any).fields\n\n  if (!fields) {\n    throw new RuntypeUsageError(`expected a record runtype`)\n  }\n\n  const newRecordFields: any = {}\n\n  for (const k in fields) {\n    if (Object.prototype.hasOwnProperty.call(fields, k)) {\n      // TODO: detect whether field is already optional and do not apply\n      // optional a second time\n      newRecordFields[k] = optional(fields[k])\n    }\n  }\n\n  // TODO: keep 'sloppyness'\n  return record(newRecordFields) as Runtype<any>\n}\n","import { record } from './record'\nimport { Runtype, RuntypeUsageError } from './runtype'\n\n/**\n * Build a new record runtype that contains some keys from the original\n */\nexport function pick<T, K extends keyof T>(\n  original: Runtype<T>,\n  ...keys: K[]\n): Runtype<Pick<T, K>> {\n  const fields = (original as any).fields\n\n  if (!fields) {\n    throw new RuntypeUsageError(`expected a record runtype`)\n  }\n\n  const newRecordFields: any = {}\n\n  keys.forEach((k: any) => {\n    newRecordFields[k] = fields[k]\n  })\n\n  // TODO: keep 'sloppyness'\n  return record(newRecordFields) as Runtype<any>\n}\n"],"names":["debugValue","v","maxLength","s","undefined","toString","JSON","stringify","length","slice","isRuntypeErrorPath","e","Array","isArray","path","getFormattedErrorPath","pathInRootElementFirstOrder","reverse","formattedErrorPath","map","k","test","join","startsWith","getFormattedErrorValue","reduceRight","key","value","isResolvable","resolvedValue","getFormattedError","rawPath","label","name","reason","RuntypeError","Error","RuntypeUsageError","failSymbol","Symbol","createFail","failOrThrow","msg","topLevelValue","propagateFail","failObj","push","isPureRuntypeSymbol","internalRuntype","fn","isPure","Object","assign","isPureRuntype","isFail","createError","runtype","res","use","r","result","ok","error","any","booleanRuntype","boolean","enumRuntype","enumObject","values","indexOf","nullRuntype","number","options","allowNaN","allowInfinity","min","max","isNaN","Infinity","objectRuntype","object","stringRuntype","string","minLength","trim","match","undefinedRuntype","unknown","literal","lit","rt","stringLiteralUnion","valuesIndex","Set","has","guardedBy","typeGuard","ignore","integerRuntype","Number","isSafeInteger","integer","n","nullOr","t","undefinedOr","optional","stringAsIntegerRuntype","parsedNumber","parseInt","vStringSansLeadingPlus","stringAsInteger","jsonRuntype","jsonData","parse","err","String","json","validationResult","arrayRuntype","array","a","arrayValue","i","item","tuple","types","every","isPureTypemap","typemap","prototype","hasOwnProperty","call","internalRecord","sloppy","typemapKeys","keys","typemapValues","o","unknownKeys","fields","getRecordFields","anyRt","record","sloppyRecord","dictionaryRuntype","keyRuntype","valueRuntype","getOwnPropertySymbols","keyOrFail","valueOrFail","dictionary","internalDiscriminatedUnion","runtypes","typeMap","Map","forEach","tagValue","set","resultingRuntype","get","unions","findDiscriminatingUnionKey","commonKeys","f","fieldRuntype","l","add","possibleKeys","val","size","union","commonKey","lastFail","recordIntersection2","recordA","recordB","b","intersection","unionIntersection2","u","unionRuntypes","intersection2","valFromA","valFromB","omit","original","newRecordFields","partial","pick"],"mappings":"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"}