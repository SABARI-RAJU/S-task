{"version":3,"file":"simple-runtypes.cjs.production.min.js","sources":["../src/runtypeError.ts","../src/runtype.ts","../src/custom.ts","../src/boolean.ts","../src/object.ts","../src/string.ts","../src/integer.ts","../src/optional.ts","../src/stringAsInteger.ts","../src/json.ts","../src/array.ts","../src/record.ts","../src/union.ts","../src/intersection.ts","../src/any.ts","../src/dictionary.ts","../src/enum.ts","../src/guardedBy.ts","../src/ignore.ts","../src/literal.ts","../src/null.ts","../src/nullOr.ts","../src/number.ts","../src/omit.ts","../src/partial.ts","../src/pick.ts","../src/stringLiteralUnion.ts","../src/tuple.ts","../src/undefined.ts","../src/undefinedOr.ts","../src/unknown.ts"],"sourcesContent":["import { RuntypeError, Fail } from './runtype'\n\ntype RuntypeErrorInfo = RuntypeError | Fail\n\n/**\n * Turn an arbitrary object into a string of max length suitable for logging.\n */\nexport function debugValue(v: unknown, maxLength = 512): string {\n  let s: string\n\n  if (v === undefined) {\n    return 'undefined'\n  }\n\n  // `JSON.stringify(fn)` would return `undefined` thus `s.length` would become\n  // `undefined.length` which would fail\n  if (typeof v === 'function') {\n    return v.toString()\n  }\n\n  try {\n    s = JSON.stringify(v)\n  } catch {\n    s = `${v}`\n  }\n\n  if (s.length > maxLength) {\n    return s.slice(0, maxLength - 1) + '\\u2026'\n  } else {\n    return s\n  }\n}\n\n/**\n * Return boolean to indicate whether passed object seems to be an RuntypeError\n */\nfunction isRuntypeErrorPath(e: RuntypeErrorInfo): boolean {\n  return Array.isArray(e.path)\n}\n\n/**\n * Return the object path at which the error occured.\n */\nexport function getFormattedErrorPath(e: RuntypeErrorInfo): string {\n  if (!isRuntypeErrorPath(e)) {\n    return '(error is not a RuntypeError!)'\n  }\n\n  // path in Fail objects is with the root-element at the end bc. its easier\n  // to build it that way (just an [].push)\n  const pathInRootElementFirstOrder = [...e.path].reverse()\n\n  const formattedErrorPath = pathInRootElementFirstOrder\n    .map((k) =>\n      typeof k === 'number'\n        ? `[${k}]`\n        : /^\\w+$/.test(k)\n        ? `.${k}`\n        : `['${JSON.stringify(k)}']`,\n    )\n    .join('')\n\n  return formattedErrorPath.startsWith('.')\n    ? formattedErrorPath.slice(1)\n    : formattedErrorPath\n}\n\n/**\n * Return a string representaiton of the value that failed the runtype check.\n *\n * Cap the size of the returned string at maxLength\n */\nexport function getFormattedErrorValue(\n  e: RuntypeErrorInfo,\n  maxLength = 512,\n): string {\n  if (!isRuntypeErrorPath(e)) {\n    return '(error is not a RuntypeError!)'\n  }\n\n  const { value: resolvedValue } = e.path.reduceRight(\n    ({ value, isResolvable }, key) => {\n      // we have not not been able to resolve the value previously - don't try any further\n      if (!isResolvable) {\n        return { value, isResolvable }\n      }\n\n      // try to resolve key within objects or arrays\n      if (key in value) {\n        return { value: value[key], isResolvable }\n      }\n\n      // otherwise return last value successfully resolved and mark as \"not further resolvable\"\n      return { value, isResolvable: false }\n    },\n    { value: e.value, isResolvable: true },\n  )\n\n  return debugValue(resolvedValue, maxLength)\n}\n\n/**\n * Return a string representation of the value that failed the runtype check.\n *\n * Cap the size of the returned string at maxLength\n */\nexport function getFormattedError(\n  e: RuntypeErrorInfo,\n  maxLength = 512,\n): string {\n  const rawPath = getFormattedErrorPath(e)\n  const path = rawPath\n    ? `<value>${rawPath.startsWith('[') ? '' : '.'}${rawPath}`\n    : '<value>'\n  const label = 'name' in e ? `${e.name}: ` : ''\n  const value = getFormattedErrorValue(e, maxLength)\n\n  return `${label}${e.reason} at \\`${path}\\` for \\`${value}\\``\n}\n","/**\n * Thrown if the input does not match the runtype.\n *\n * Use `getFormattedErrorPath`, `getFormattedErrorValue` and\n * `getFormattedError` to convert path and value to a loggable string.\n */\nexport class RuntypeError extends Error {\n  // implements RuntypeErrorInfo\n  readonly path: (string | number)[]\n  readonly value: any\n  readonly reason: string\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(reason: string, value: any, path: (string | number)[]) {\n    super(reason)\n\n    this.name = 'RuntypeError'\n    this.reason = reason\n    this.path = path\n    this.value = value\n  }\n}\n\n/**\n * Thrown if the api is misused.\n */\nexport class RuntypeUsageError extends Error {}\n\n/**\n * Symbol that identifies failed typechecks\n */\nexport const failSymbol: unique symbol = Symbol('SimpleRuntypesFail')\n\n/**\n * Object to return internally if a typecheck failed\n *\n * This is used internally to avoid creating garbage for each runtype\n * validation call.\n */\nexport interface Fail {\n  [failSymbol]: true // marker to be able to distinguish Fail from other objects\n  reason: string\n  path: (string | number)[]\n  value?: any\n}\n\n// create a fail or raise the error exception if the called runtype was on top\nexport function createFail(\n  failOrThrow: typeof failSymbol | undefined,\n  msg: string,\n  topLevelValue?: unknown,\n): any {\n  if (failOrThrow === undefined) {\n    // runtype check failed\n    throw new RuntypeError(msg, topLevelValue, [])\n  } else if (failOrThrow === failSymbol) {\n    // runtype check failed but it should not throw an exception bc its called\n    // internally e.g. as part of a union or because we want to add debug info\n    // while unrolling the stack\n    return {\n      [failSymbol]: true,\n      reason: msg,\n      path: [],\n      value: undefined,\n    }\n  } else {\n    throw new RuntypeUsageError(\n      `failOrThrow must be undefined or the failSymbol, not ${JSON.stringify(\n        failOrThrow,\n      )}`,\n    )\n  }\n}\n\n// pass the fail up to the caller or, if on top, raise the error exception\nexport function propagateFail(\n  failOrThrow: typeof failSymbol | undefined,\n  failObj: Fail,\n  topLevelValue?: unknown,\n  key?: string | number,\n): Fail {\n  if (key !== undefined) {\n    failObj.path.push(key)\n  }\n\n  if (failOrThrow === undefined) {\n    // runtype check failed\n    throw new RuntypeError(failObj.reason, topLevelValue, failObj.path)\n  } else if (failOrThrow === failSymbol) {\n    return failObj\n  } else {\n    throw new RuntypeUsageError(\n      `failOrThrow must be undefined or the failSymbol, not ${JSON.stringify(\n        failOrThrow,\n      )}`,\n    )\n  }\n}\n\n/**\n * Runtype\n *\n * Just a function. The returned value may be a copy of v, depending on the\n * runtypes implementation.\n */\nexport interface Runtype<T> {\n  /**\n   * A function to check that v 'conforms' to type T\n   *\n   * By default, Raises a RuntypeError if the check fails.\n   * With `useRuntype(runtype, value)` it will return a `ValidationResult` instead.\n   */\n  (v: unknown): T\n}\n\n/**\n * Special runtype for use in record definitions to mark optional keys.\n */\nexport interface OptionalRuntype<T> {\n  isOptionalRuntype: true\n  (v: unknown): T\n}\n\nexport type Unpack<T> = T extends Runtype<infer U>\n  ? U\n  : T extends OptionalRuntype<infer V>\n  ? V\n  : never\n\n// force Typescript to boil down complex mapped types to a plain interface\nexport type Collapse<T> = T extends infer U ? { [K in keyof U]: U[K] } : never\n\nexport const isPureRuntypeSymbol = Symbol('isPure')\n\n// The internal runtype is one that receives an additional flag that\n// determines whether the runtype should throw a RuntypeError or whether it\n// should return a Fail up to the caller.\n//\n// Use this to:\n//   * accumulate additional path data when unwinding a fail (propagateFail)\n//   * have runtypes return a dedicated fail value to implement union over any\n//     runtypes (isFail)\n//\n// Pass `true` as isPure to signal that this runtype is not modifying its\n// value (checked with `isPureRuntype`\nexport function internalRuntype<T>(\n  fn: (v: unknown, failOrThrow?: typeof failSymbol) => T,\n  isPure?: boolean,\n): Runtype<T> {\n  if (isPure === true) {\n    return Object.assign(fn, { isPure: isPureRuntypeSymbol })\n  } else if (isPure === undefined || isPure === false) {\n    return fn\n  } else {\n    throw new RuntypeUsageError(\n      'expected \"isPure\" or undefined as the second argument',\n    )\n  }\n}\n\n/**\n * A pure runtype does not change its value.\n *\n * A non-pure runtype may return a changed value.\n * This is used to get rid of redundant object copying\n */\nexport function isPureRuntype(fn: Runtype<any>): boolean {\n  return !!(fn as any).isPure\n}\n\nexport type InternalRuntype = (\n  v: unknown,\n  failOrThrow: typeof failSymbol | undefined,\n) => any\n\n/**\n * Check whether a returned value is a failure.\n */\nexport function isFail(v: unknown): v is Fail {\n  if (typeof v !== 'object' || !v) {\n    return false\n  }\n\n  return (v as any)[failSymbol]\n}\n","import {\n  createFail,\n  Fail,\n  failSymbol,\n  internalRuntype,\n  InternalRuntype,\n  isFail,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\n/**\n * Create a validation error for custom runtypes\n */\nexport function createError(msg: string): Fail {\n  return createFail(failSymbol, msg)\n}\n\n/**\n * Construct a custom runtype from a validation function.\n */\nexport function runtype<T>(fn: (v: unknown) => T | Fail): Runtype<T> {\n  return internalRuntype<any>((v, failOrThrow) => {\n    const res = fn(v)\n\n    if (isFail(res)) {\n      return propagateFail(failOrThrow, res, v)\n    }\n\n    return res\n  })\n}\n\n/**\n * Explicit validation result containing the wrapped result or error.\n */\nexport type ValidationResult<T> =\n  | { ok: true; result: T }\n  | { ok: false; error: Fail }\n\n/**\n * Execute a runtype but do not throw Errors\n *\n * Return a ValidationResult instead.\n * When its an Error, use `getFormattedError` on it to get a well formatted\n * message for logging or reporting.\n *\n * Useful when writing your own runtypes and when the bad performance of\n * exceptions and try-catch for error handling is of concern.\n */\nexport function use<T>(r: Runtype<T>, v: unknown): ValidationResult<T> {\n  const result = (r as InternalRuntype)(v, failSymbol)\n\n  if (isFail(result)) {\n    // we don't know who is using the result (passing error up the stack or\n    // consuming it with e.g. `st.getFormattedError`) so set the toplevel\n    // value (will be overwritten in case we're passed up anyways)\n    result.value = v\n\n    return { ok: false, error: result }\n  }\n\n  return { ok: true, result }\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\nconst booleanRuntype = internalRuntype<boolean>((v, failOrThrow) => {\n  if (v === true || v === false) {\n    return v\n  }\n\n  return createFail(failOrThrow, 'expected a boolean', v)\n}, true)\n\n/**\n * A boolean.\n */\nexport function boolean(): Runtype<boolean> {\n  return booleanRuntype\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n// cached object runtype\nexport const objectRuntype = internalRuntype<object>((v, failOrThrow) => {\n  if (typeof v === 'object' && !Array.isArray(v) && v !== null) {\n    return v\n  }\n\n  return createFail(failOrThrow, 'expected an object', v)\n}, true)\n\n/**\n * An object that is not an array.\n */\nexport function object(): Runtype<object> {\n  return objectRuntype\n}\n","import {\n  createFail,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\nconst stringRuntype = internalRuntype<string>((v, failOrThrow) => {\n  if (typeof v === 'string') {\n    return v\n  }\n\n  return createFail(failOrThrow, 'expected a string', v)\n}, true)\n\n/**\n * A string.\n *\n * Options:\n *\n *   minLength .. reject strings that are shorter than that\n *   maxLength .. reject strings that are longer than that\n *   trim .. when true, remove leading and trailing spaces from the string\n *   match .. reject strings that do not match against provided RegExp\n */\nexport function string(options?: {\n  minLength?: number\n  maxLength?: number\n  trim?: boolean\n  match?: RegExp\n}): Runtype<string> {\n  if (!options) {\n    return stringRuntype\n  }\n\n  const { minLength, maxLength, trim, match } = options\n\n  const isPure = !trim // trim modifies the string\n\n  return internalRuntype((v, failOrThrow) => {\n    const s: string = (stringRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(s)) {\n      return propagateFail(failOrThrow, s, v)\n    }\n\n    if (minLength !== undefined && s.length < minLength) {\n      return createFail(\n        failOrThrow,\n        `expected the string length to be at least ${minLength}`,\n        v,\n      )\n    }\n\n    if (maxLength !== undefined && s.length > maxLength) {\n      return createFail(\n        failOrThrow,\n        `expected the string length to not exceed ${maxLength}`,\n        v,\n      )\n    }\n\n    if (match !== undefined && !match.test(s)) {\n      return createFail(failOrThrow, `expected the string to match ${match}`, v)\n    }\n\n    return trim ? s.trim() : s\n  }, isPure)\n}\n","import {\n  createFail,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\nexport const integerRuntype = internalRuntype<number>((v, failOrThrow) => {\n  if (typeof v === 'number' && Number.isSafeInteger(v)) {\n    return v\n  }\n\n  return createFail(failOrThrow, 'expected a safe integer', v)\n}, true)\n\n/**\n * A Number that is a `isSafeInteger()`\n *\n * Options:\n *\n *   min .. reject numbers smaller than that\n *   max .. reject number larger than that\n */\nexport function integer(options?: {\n  max?: number\n  min?: number\n}): Runtype<number> {\n  if (!options) {\n    return integerRuntype\n  }\n\n  const { min, max } = options\n\n  return internalRuntype<number>((v, failOrThrow) => {\n    const n = (integerRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(n)) {\n      return propagateFail(failOrThrow, n, v)\n    }\n\n    if (min !== undefined && n < min) {\n      return createFail(failOrThrow, `expected the integer to be >= ${min}`, v)\n    }\n\n    if (max !== undefined && n > max) {\n      return createFail(failOrThrow, `expected the integer to be <= ${max}`, v)\n    }\n\n    return n\n  }, true)\n}\n","import {\n  InternalRuntype,\n  internalRuntype,\n  isPureRuntype,\n  OptionalRuntype,\n  Runtype,\n} from './runtype'\n\n/**\n * Optional (?), only usable within `record`\n *\n * Marks the key its used on as optional, e.g.:\n *\n *    record({foo: optional(string())})\n *\n *    => {foo?: string}\n */\nexport function optional<A>(t: Runtype<A>): OptionalRuntype<A> {\n  const isPure = isPureRuntype(t)\n\n  const rt = internalRuntype((v, failOrThrow) => {\n    if (v === undefined) {\n      return undefined\n    }\n\n    return (t as InternalRuntype)(v, failOrThrow)\n  }, isPure) as OptionalRuntype<A>\n\n  return rt\n}\n","import { integerRuntype } from './integer'\nimport {\n  createFail,\n  failSymbol,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\nexport const stringAsIntegerRuntype = internalRuntype<number>(\n  (v, failOrThrow) => {\n    if (typeof v === 'string') {\n      const parsedNumber = parseInt(v, 10)\n      const n: number = (integerRuntype as InternalRuntype)(\n        parsedNumber,\n        failSymbol,\n      )\n\n      if (isFail(n)) {\n        return propagateFail(failOrThrow, n, v)\n      }\n\n      // ensure that value did only contain that integer, nothing else\n      // but also make '+1' === '1' and '-0' === '0'\n      const vStringSansLeadingPlus =\n        v === '-0' ? '0' : v[0] === '+' ? v.slice(1) : v\n\n      if (n.toString() !== vStringSansLeadingPlus) {\n        return createFail(\n          failOrThrow,\n          'expected string to contain only the safe integer, not additional characters, whitespace or leading zeros',\n          v,\n        )\n      }\n\n      return n\n    }\n\n    return createFail(\n      failOrThrow,\n      'expected a string that contains a safe integer',\n      v,\n    )\n  },\n)\n\n/**\n * A string that is parsed as an integer.\n *\n * Parsing is strict, e.g leading/trailing whitespace or leading zeros will\n * result in an error. Exponential notation is not allowed. The resulting\n * number must be a safe integer (`Number.isSafeInteger`).\n * A leading '+' or '-' is allowed.\n *\n * Options:\n *\n *   min .. reject numbers smaller than that\n *   max .. reject number larger than that\n */\nexport function stringAsInteger(options?: {\n  min?: number\n  max?: number\n}): Runtype<number> {\n  if (!options) {\n    return stringAsIntegerRuntype\n  }\n\n  const { min, max } = options\n\n  return internalRuntype<number>((v, failOrThrow) => {\n    const n = (stringAsIntegerRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(n)) {\n      return propagateFail(failOrThrow, n, v)\n    }\n\n    if (min !== undefined && n < min) {\n      return createFail(failOrThrow, `expected the integer to be >= ${min}`, v)\n    }\n\n    if (max !== undefined && n > max) {\n      return createFail(failOrThrow, `expected the integer to be <= ${max}`, v)\n    }\n\n    return n\n  })\n}\n","import {\n  createFail,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  propagateFail,\n  Runtype,\n} from './runtype'\nimport { use } from './custom'\n\nexport const jsonRuntype = internalRuntype<unknown>((v, failOrThrow) => {\n  if (!(typeof v === 'string')) {\n    return createFail(failOrThrow, 'expected a json string', v)\n  }\n\n  try {\n    const jsonData = JSON.parse(v)\n    return jsonData\n  } catch (err) {\n    return createFail(failOrThrow, 'expected a json string: ' + String(err), v)\n  }\n}, false)\n\n/**\n * A String that is valid json\n */\nexport function json<T>(rt: Runtype<T>): Runtype<T> {\n  return internalRuntype<any>((v, failOrThrow) => {\n    const n = (jsonRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(n)) {\n      return propagateFail(failOrThrow, n, v)\n    }\n\n    const validationResult = use(rt, n)\n\n    if (!validationResult.ok) {\n      return propagateFail(failOrThrow, validationResult.error, v)\n    }\n\n    return validationResult.result\n  }, false)\n}\n","import {\n  createFail,\n  failSymbol,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\nexport const arrayRuntype = internalRuntype<unknown[]>((v, failOrThrow) => {\n  if (Array.isArray(v)) {\n    return v\n  }\n\n  return createFail(failOrThrow, `expected an Array`, v)\n}, true)\n\n/**\n * An array of a given type.\n *\n * Options:\n *\n *   minLength .. reject arrays shorter than that\n *   maxLength .. reject arrays longer than that\n */\nexport function array<A>(\n  a: Runtype<A>,\n  options?: { maxLength?: number; minLength?: number },\n): Runtype<A[]> {\n  const { maxLength, minLength } = options || {}\n\n  const isPure = isPureRuntype(a)\n\n  return internalRuntype<any>((v, failOrThrow) => {\n    const arrayValue = (arrayRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(arrayValue)) {\n      return propagateFail(failOrThrow, arrayValue, v)\n    }\n\n    if (maxLength !== undefined && arrayValue.length > maxLength) {\n      return createFail(\n        failOrThrow,\n        `expected the array to contain at most ${maxLength} elements`,\n        v,\n      )\n    }\n\n    if (minLength !== undefined && arrayValue.length < minLength) {\n      return createFail(\n        failOrThrow,\n        `expected the array to contain at least ${minLength} elements`,\n        v,\n      )\n    }\n\n    // copy the unknown array in case the item runtype is not pure (we do not mutate anything in place)\n    const res: A[] = isPure ? arrayValue : new Array(arrayValue.length)\n\n    for (let i = 0; i < arrayValue.length; i++) {\n      const item = (a as InternalRuntype)(arrayValue[i], failSymbol)\n\n      if (isFail(item)) {\n        return propagateFail(failOrThrow, item, v, i)\n      }\n\n      if (!isPure) {\n        res[i] = item\n      }\n    }\n\n    return res\n  }, isPure)\n}\n","import {\n  createFail,\n  failSymbol,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n  Runtype,\n  OptionalRuntype,\n  Collapse,\n  Unpack,\n} from './runtype'\nimport { debugValue } from './runtypeError'\n\nfunction isPureTypemap(typemap: object) {\n  for (const k in typemap) {\n    if (!Object.prototype.hasOwnProperty.call(typemap, k)) {\n      continue\n    }\n\n    if (!isPureRuntype(typemap[k as keyof typeof typemap])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction internalRecord(\n  typemap: { [key: string]: Runtype<any> | OptionalRuntype<any> },\n  sloppy: boolean,\n): Runtype<any> {\n  // a sloppy record may ignore keys and so cannot be pure\n  const isPure = !sloppy && isPureTypemap(typemap)\n\n  // cache typemap in arrays for a faster loop\n  const typemapKeys = [...Object.keys(typemap)]\n  const typemapValues = [...Object.values(typemap)]\n\n  const rt = internalRuntype((v, failOrThrow) => {\n    // inlined object runtype for perf\n    if (typeof v !== 'object' || Array.isArray(v) || v === null) {\n      return createFail(failOrThrow, 'expected an object', v)\n    }\n\n    const o: any = v\n\n    // optimize allocations: only create a copy if the record is impure\n    const res = isPure ? o : {}\n\n    for (let i = 0; i < typemapKeys.length; i++) {\n      const k = typemapKeys[i]\n      const t = typemapValues[i] as InternalRuntype\n\n      // nested types should always fail with explicit `Fail` so we can add additional data\n      const value = t(o[k], failSymbol)\n\n      if (isFail(value)) {\n        if (!(k in o)) {\n          // rt failed because o[k] was undefined bc. the key was missing from o\n          // use a more specific error message in this case\n          return createFail(\n            failOrThrow,\n            `missing key in record: ${debugValue(k)}`,\n          )\n        }\n\n        return propagateFail(failOrThrow, value, v, k)\n      }\n\n      if (!isPure) {\n        res[k] = value\n      }\n    }\n\n    if (!sloppy) {\n      const unknownKeys: string[] = []\n\n      for (const k in o) {\n        if (!Object.prototype.hasOwnProperty.call(typemap, k)) {\n          unknownKeys.push(o)\n        }\n      }\n\n      if (unknownKeys.length) {\n        return createFail(\n          failOrThrow,\n          `invalid keys in record ${debugValue(unknownKeys)}`,\n          v,\n        )\n      }\n    }\n\n    return res\n  }, isPure)\n\n  // fields metadata to implement combinators like (discriminated) unions,\n  // pick, omit and intersection\n  const fields: { [key: string]: any } = {}\n\n  for (const k in typemap) {\n    fields[k] = typemap[k]\n  }\n\n  // eslint-disable-next-line no-extra-semi\n  ;(rt as any).fields = fields\n\n  return rt\n}\n\nexport function getRecordFields(\n  r: Runtype<any>,\n): { [key: string]: Runtype<any> } | undefined {\n  const anyRt: any = r\n\n  if (!anyRt.fields) {\n    return\n  }\n\n  return anyRt.fields\n}\n\n/**\n * An object with defined keys and values.\n *\n * In contrast to typescript types, objects checked by this runtype will fail\n * if they have any additional keys (strict checking) not specified in\n * typemap.\n *\n * Keeps you save from unwanted propertiers and evil __proto__ injections.\n */\nexport function record<\n  T,\n  Typemap = { [K in keyof T]: Runtype<T[K]> | OptionalRuntype<T[K]> },\n  OptionalKeys extends keyof Typemap = {\n    [K in keyof Typemap]: Typemap[K] extends OptionalRuntype<any> ? K : never\n  }[keyof Typemap]\n>(\n  typemap: Typemap,\n): Runtype<\n  Collapse<\n    { [K in Exclude<keyof Typemap, OptionalKeys>]: Unpack<Typemap[K]> } &\n      { [K in OptionalKeys]?: Unpack<Typemap[K]> }\n  >\n> {\n  return internalRecord(typemap as any, false)\n}\n\n/**\n * Like record but ignore unknown keys.\n *\n * Returns a new object that only contains the keys specified in the typemap.\n * Additional keys are ignored.\n *\n * Keeps you save from unwanted propertiers and evil __proto__ injections.\n */\nexport function sloppyRecord<\n  T,\n  Typemap = { [K in keyof T]: Runtype<T[K]> | OptionalRuntype<T[K]> },\n  OptionalKeys extends keyof Typemap = {\n    [K in keyof Typemap]: Typemap[K] extends OptionalRuntype<any> ? K : never\n  }[keyof Typemap]\n>(\n  typemap: Typemap,\n): Runtype<\n  Collapse<\n    { [K in Exclude<keyof Typemap, OptionalKeys>]: Unpack<Typemap[K]> } &\n      { [K in OptionalKeys]?: Unpack<Typemap[K]> }\n  >\n> {\n  return internalRecord(typemap as any, true)\n}\n","import { objectRuntype } from './object'\nimport { getRecordFields } from './record'\nimport {\n  createFail,\n  Fail,\n  failSymbol,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n  Runtype,\n  RuntypeUsageError,\n} from './runtype'\nimport { debugValue } from './runtypeError'\n\n// A tagged union with type discriminant 'key'.\n// Runtypes must be created with `record(...)` which contains type metadata to\n// identify the literals in each record.\n// Perform an efficient lookup of runtype functions by checking the\n// discriminant key and using the runtype that matches it. This results 1\n// runtype check vs man in the naive union check implementation.\nfunction internalDiscriminatedUnion(\n  key: string,\n  runtypes: Runtype<any>[],\n): Runtype<any> {\n  const typeMap = new Map<string | number, Runtype<any>>()\n\n  // build an index for fast runtype lookups by literal\n  runtypes.forEach((t: any) => {\n    const rt = t.fields[key]\n    const tagValue = rt.literal\n\n    if (tagValue === undefined) {\n      throw new RuntypeUsageError(\n        `broken record type definition, ${t}[${key}] is not a literal`,\n      )\n    }\n\n    if (!(typeof tagValue === 'string' || typeof tagValue === 'number')) {\n      throw new RuntypeUsageError(\n        `broken record type definition, ${t}[${key}] must be a string or number, not ${debugValue(\n          tagValue,\n        )}`,\n      )\n    }\n\n    // use `object` to also allow enums but they can't be used in types\n    // for keys of indexes so we need any\n    typeMap.set(tagValue, t)\n  })\n\n  const isPure = runtypes.every((t) => isPureRuntype(t))\n\n  const resultingRuntype = internalRuntype((v, failOrThrow) => {\n    const o: any = (objectRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(o)) {\n      return propagateFail(failOrThrow, o, v)\n    }\n\n    const tagValue = o[key]\n    const rt = typeMap.get(tagValue)\n\n    if (rt === undefined) {\n      return createFail(\n        failOrThrow,\n        `no Runtype found for discriminated union tag ${key}: ${debugValue(\n          tagValue,\n        )}`,\n        v,\n      )\n    }\n\n    return (rt as InternalRuntype)(v, failOrThrow)\n  }, isPure)\n\n  // keep the union runtypes around to implement combinators that need to distribute across unions like intersection\n  ;(resultingRuntype as any).unions = runtypes\n\n  return resultingRuntype\n}\n\n// given a list of runtypes, return the name of the key that acts as the\n// unique discriminating value across all runtypes\n// return undefined if no such key exists\nfunction findDiscriminatingUnionKey(\n  runtypes: Runtype<any>[],\n): string | undefined {\n  const commonKeys = new Map<string, Set<string>>()\n\n  for (let i = 0; i < runtypes.length; i++) {\n    const r = runtypes[i]\n    const fields = getRecordFields(r)\n\n    if (!fields) {\n      // not a record runtype -> no common tag key\n      return\n    }\n\n    for (const f in fields) {\n      const fieldRuntype = fields[f]\n      const l = (fieldRuntype as any).literal\n\n      if (l !== undefined) {\n        // found a literal value, add it to the field\n        // if we get a distinct literalruntype, we can use the optimized\n        // index-accessed internalDiscriminatedUnion runtype\n        if (!commonKeys.has(f)) {\n          commonKeys.set(f, new Set())\n        }\n\n        commonKeys.get(f)?.add(l)\n      }\n    }\n  }\n\n  const possibleKeys: string[] = []\n\n  commonKeys.forEach((val, key) => {\n    // when the key has a unique value for each runtype it can be used as a discriminant\n    if (val.size === runtypes.length) {\n      possibleKeys.push(key)\n    }\n  })\n\n  if (!possibleKeys.length) {\n    return\n  }\n\n  // just use the first key (any key in possibleKeys would suffice)\n  return possibleKeys[0]\n}\n\n// helper type to get the type of a runtype\ntype UnpackRuntypes<T extends Runtype<any>> = T extends Runtype<infer R>\n  ? R\n  : never\n\n/**\n * A union of runtypes.\n */\nexport function union<V extends Runtype<any>[]>(\n  ...runtypes: V\n): Runtype<UnpackRuntypes<V[number]>> {\n  if (!runtypes.length) {\n    throw new RuntypeUsageError('no runtypes given to union')\n  }\n\n  // optimize: when the union is a discriminating union, find the\n  // discriminating key and use it to look up the runtype for the keys value\n  const commonKey = findDiscriminatingUnionKey(runtypes)\n\n  if (commonKey !== undefined) {\n    return internalDiscriminatedUnion(commonKey, runtypes)\n  }\n\n  const isPure = runtypes.every((t) => isPureRuntype(t))\n\n  // simple union validation: try all runtypes and use the first one that\n  // doesn't fail\n  return internalRuntype((v, failOrThrow) => {\n    let lastFail: Fail | undefined\n\n    for (let i = 0; i < runtypes.length; i++) {\n      const val = (runtypes[i] as InternalRuntype)(v, failSymbol)\n\n      if (!isFail(val)) {\n        return val\n      } else {\n        lastFail = val\n      }\n    }\n\n    return propagateFail(failOrThrow, lastFail as any, v)\n  }, isPure)\n}\n","import { union } from './union'\nimport { record } from './record'\nimport {\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n  Runtype,\n  RuntypeUsageError,\n} from './runtype'\n\n// An intersection of two record runtypes\nfunction recordIntersection2<A, B>(\n  recordA: Runtype<A>,\n  recordB: Runtype<B>,\n): Runtype<A & B> {\n  const fields: { [key: string]: Runtype<any> } = {}\n  const a = (recordA as any).fields\n  const b = (recordB as any).fields\n\n  for (const k in { ...a, ...b }) {\n    if (a[k] && b[k]) {\n      fields[k] = intersection(a[k], b[k])\n    } else if (a[k]) {\n      fields[k] = a[k]\n    } else if (b[k]) {\n      fields[k] = b[k]\n    } else {\n      throw new RuntypeUsageError('recordIntersection2: invalid else')\n    }\n  }\n\n  // results in a new record type\n  return record<any>(fields)\n}\n\n// An intersection of a union with another type\nfunction unionIntersection2<A, B>(\n  u: Runtype<A>,\n  b: Runtype<B>,\n): Runtype<A & B> {\n  const unionRuntypes: Runtype<any>[] = (u as any).unions\n\n  if (\n    !unionRuntypes ||\n    !Array.isArray(unionRuntypes) ||\n    !unionRuntypes.length\n  ) {\n    throw new RuntypeUsageError(\n      'unionIntersection2: first argument is not a union type',\n    )\n  }\n\n  // results in a new union (because the intersection distributes over the union)\n  return union<Runtype<any>[]>(\n    ...unionRuntypes.map((a) => intersection2<any, any>(a, b)),\n  )\n}\n\n/**\n * An intersection of two runtypes.\n *\n * In case the intersection contains records or unions (of records), create a\n * completely new record or union runtype.\n */\nfunction intersection2<A, B>(a: Runtype<A>, b: Runtype<B>): Runtype<A & B>\nfunction intersection2(a: Runtype<any>, b: Runtype<any>): Runtype<any> {\n  if ('fields' in a && 'fields' in b) {\n    return recordIntersection2(a, b)\n  } else if ('unions' in a && 'fields' in b) {\n    return unionIntersection2(a, b)\n  } else if ('unions' in b && 'fields' in a) {\n    return unionIntersection2(b, a)\n  } else if ('fields' in a || 'fields' in b) {\n    // Does such an intersection (e.g. string | {a: number} even make sense?\n    // And how would you implement it?\n    throw new RuntypeUsageError(\n      'intersection2: cannot intersect a base type with a record',\n    )\n  } else {\n    const isPure = isPureRuntype(a) && isPureRuntype(b)\n\n    return internalRuntype((v, failOrThrow) => {\n      const valFromA = (a as InternalRuntype)(v, failOrThrow)\n      const valFromB = (b as InternalRuntype)(v, failOrThrow)\n\n      if (isFail(valFromB)) {\n        return propagateFail(failOrThrow, valFromB, v)\n      }\n\n      if (isFail(valFromA)) {\n        return propagateFail(failOrThrow, valFromA, v)\n      }\n\n      return valFromB // second runtype arg is preferred\n    }, isPure)\n  }\n}\n\n/**\n * An intersection of runtypes.\n */\nexport function intersection<A, B>(a: Runtype<A>, b: Runtype<B>): Runtype<A & B>\nexport function intersection<A, B, C>(\n  a: Runtype<A>,\n  b: Runtype<B>,\n  c: Runtype<C>,\n): Runtype<A & B & C>\nexport function intersection(...args: Runtype<any>[]): Runtype<any> {\n  if (args.length === 2) {\n    return intersection2(args[0], args[1])\n  } else if (args.length === 3) {\n    return intersection(intersection2(args[0], args[1]), args[2])\n  } else {\n    throw new RuntypeUsageError(\n      `unsupported number of arguments ${args.length}`,\n    )\n  }\n}\n","import { Runtype, internalRuntype } from './runtype'\n\n/**\n * A value to check later.\n */\nexport function any(): Runtype<any> {\n  return internalRuntype((v) => {\n    return v as any\n  }, true)\n}\n","import { objectRuntype } from './object'\nimport {\n  createFail,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n} from './runtype'\nimport { debugValue } from './runtypeError'\nimport type { Runtype, InternalRuntype, Fail } from './runtype'\n\nfunction dictionaryRuntype<T extends string, U>(\n  keyRuntype: Runtype<T>,\n  valueRuntype: Runtype<U>,\n) {\n  const isPure = isPureRuntype(keyRuntype) && isPureRuntype(valueRuntype)\n\n  return internalRuntype<Record<T, U>>((v, failOrThrow) => {\n    const o: object | Fail = (objectRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(o)) {\n      return propagateFail(failOrThrow, o, v)\n    }\n\n    if (Object.getOwnPropertySymbols(o).length) {\n      return createFail(\n        failOrThrow,\n        `invalid key in dictionary: ${debugValue(\n          Object.getOwnPropertySymbols(o),\n        )}`,\n        v,\n      )\n    }\n\n    // optimize allocations: only create a copy if any of the key runtypes\n    // return a different object - otherwise return value as is\n    const res = (isPure ? o : {}) as { [key: string]: U }\n\n    for (const key in o) {\n      if (!Object.prototype.hasOwnProperty.call(o, key)) {\n        continue\n      }\n\n      if (key === '__proto__') {\n        // e.g. someone tried to sneak __proto__ into this object and that\n        // will cause havoc when assigning it to a new object (in case its impure)\n        return createFail(\n          failOrThrow,\n          `invalid key in dictionary: ${debugValue(key)}`,\n          v,\n        )\n      }\n      const keyOrFail: T | Fail = (keyRuntype as InternalRuntype)(\n        key,\n        failOrThrow,\n      )\n\n      if (isFail(keyOrFail)) {\n        return propagateFail(failOrThrow, keyOrFail, v)\n      }\n\n      const value = o[key as keyof typeof o]\n      const valueOrFail: U | Fail = (valueRuntype as InternalRuntype)(\n        value,\n        failOrThrow,\n      )\n\n      if (isFail(valueOrFail)) {\n        return propagateFail(failOrThrow, valueOrFail, v)\n      }\n\n      if (!isPure) {\n        res[keyOrFail] = valueOrFail\n      }\n    }\n\n    return res\n  }, isPure)\n}\n\n/**\n * An object that matches a Typecript `Record<KeyType, ValueType>` type.\n *\n * You pass a runtype for the objects keys and one for its values.\n * Keeps you save from unwanted propertiers and evil __proto__ injections.\n */\nexport function dictionary<T extends Runtype<any>, U extends Runtype<any>>(\n  keyRuntype: T,\n  valueRuntype: U,\n): Runtype<Record<ReturnType<T>, ReturnType<U>>> {\n  return dictionaryRuntype(keyRuntype, valueRuntype)\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\nimport { debugValue } from './runtypeError'\n\ntype EnumObject = { [key: string]: string | number }\n\n/**\n * Any value defined in the enumObject.\n */\nfunction enumRuntype<T extends EnumObject, S extends keyof T>(\n  enumObject: T,\n): Runtype<T[S]> {\n  return internalRuntype((v, failOrThrow) => {\n    // use the fast reverse lookup of number enums to check whether v is a\n    // value of the enum\n    if (typeof v === 'number' && (enumObject as any)[v as any] !== undefined) {\n      return (v as unknown) as T[S]\n    }\n\n    if (Object.values(enumObject).indexOf(v as any) !== -1) {\n      return v as T[S]\n    }\n\n    return createFail(\n      failOrThrow,\n      `expected a value that belongs to the enum ${debugValue(enumObject)}`,\n      v,\n    )\n  }, true)\n}\n\nexport { enumRuntype as enum }\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * A runtype based on a type guard\n */\nexport function guardedBy<F>(typeGuard: (v: unknown) => v is F): Runtype<F> {\n  return internalRuntype((v, failOrThrow) => {\n    if (!typeGuard(v)) {\n      return createFail(failOrThrow, 'expected typeguard to return true', v)\n    }\n\n    return v\n  }, true)\n}\n","import { internalRuntype, Runtype } from './runtype'\n\n/**\n * A value to ignore (typed as unknown and always set to undefined).\n */\nexport function ignore(): Runtype<unknown> {\n  return internalRuntype(() => {\n    return undefined as unknown\n  }, true)\n}\n","import { debugValue } from './runtypeError'\nimport { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * A literal string, number, boolean or enum.\n */\nexport function literal<T extends string>(lit: T): Runtype<T>\nexport function literal<T extends number>(lit: T): Runtype<T>\nexport function literal<T extends boolean>(lit: T): Runtype<T>\nexport function literal(lit: string | number | boolean): Runtype<any> {\n  const rt: any = internalRuntype((v, failOrThrow) => {\n    if (v === lit) {\n      return lit\n    }\n\n    return createFail(failOrThrow, `expected a literal: ${debugValue(lit)}`, v)\n  }, true)\n\n  // keep the literal as metadata on the runtype itself to be able to use it\n  // in record intersections to determine the right record runtype\n  rt.literal = lit\n\n  return rt\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * null\n */\n// eslint-disable-next-line no-shadow-restricted-names\nfunction nullRuntype(): Runtype<null> {\n  return internalRuntype<null>((v, failOrThrow) => {\n    if (v !== null) {\n      return createFail(failOrThrow, 'expected null', v)\n    }\n\n    return v\n  }, true)\n}\n\nexport { nullRuntype as null }\n","import {\n  InternalRuntype,\n  internalRuntype,\n  isPureRuntype,\n  Runtype,\n} from './runtype'\n\n/**\n * Shortcut for a type or null.\n */\nexport function nullOr<A>(t: Runtype<A>): Runtype<A | null> {\n  const isPure = isPureRuntype(t)\n\n  return internalRuntype((v, failOrThrow) => {\n    if (v === null) {\n      return null\n    }\n\n    return (t as InternalRuntype)(v, failOrThrow)\n  }, isPure)\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * A number. By default reject NaN and Infinity values.\n *\n * Options:\n *\n *   allowNaN .. allow NaN values\n *   allowInfinity .. allow positive and negative Infinity values\n *   min .. reject numbers smaller than that\n *   max .. reject numbers larger than that\n */\nexport function number(options?: {\n  allowNaN?: boolean\n  allowInfinity?: boolean\n  min?: number\n  max?: number\n}): Runtype<number> {\n  const { allowNaN, allowInfinity, min, max } = options || {}\n\n  return internalRuntype<number>((v, failOrThrow) => {\n    if (typeof v !== 'number') {\n      return createFail(failOrThrow, 'expected a number', v)\n    }\n\n    if (!allowNaN && isNaN(v)) {\n      return createFail(failOrThrow, 'expected a number that is not NaN', v)\n    }\n\n    if (!allowInfinity && (v === Infinity || v === -Infinity)) {\n      return createFail(failOrThrow, 'expected a finite number', v)\n    }\n\n    if (min !== undefined && v < min) {\n      return createFail(failOrThrow, `expected number to be >= ${min}`, v)\n    }\n\n    if (max !== undefined && v > max) {\n      return createFail(failOrThrow, `expected number to be <= ${max}`, v)\n    }\n\n    return v\n  }, true)\n}\n","import { record } from './record'\nimport { Runtype, RuntypeUsageError } from './runtype'\n\n/**\n * Build a new record runtype that omits some keys from the original.\n */\n// TODO: should work with unions too!!!!!\nexport function omit<T, K extends keyof T>(\n  original: Runtype<T>,\n  ...keys: K[]\n): Runtype<Omit<T, K>> {\n  const fields = (original as any).fields\n\n  if (!fields) {\n    throw new RuntypeUsageError(`expected a record runtype`)\n  }\n\n  const newRecordFields: any = { ...fields }\n\n  keys.forEach((k: any) => {\n    delete newRecordFields[k]\n  })\n\n  // TODO: keep 'sloppyness'\n  return record(newRecordFields) as Runtype<any>\n}\n","import { optional } from './optional'\nimport { record } from './record'\nimport { Runtype, RuntypeUsageError } from './runtype'\n\n/**\n * Build a new record runtype that marks all keys as optional.\n *\n * This is the runtype counterpart to `Partial<T>`.\n */\nexport function partial<T, K extends keyof T>(\n  original: Runtype<T>,\n): Runtype<Partial<T>> {\n  const fields = (original as any).fields\n\n  if (!fields) {\n    throw new RuntypeUsageError(`expected a record runtype`)\n  }\n\n  const newRecordFields: any = {}\n\n  for (const k in fields) {\n    if (Object.prototype.hasOwnProperty.call(fields, k)) {\n      // TODO: detect whether field is already optional and do not apply\n      // optional a second time\n      newRecordFields[k] = optional(fields[k])\n    }\n  }\n\n  // TODO: keep 'sloppyness'\n  return record(newRecordFields) as Runtype<any>\n}\n","import { record } from './record'\nimport { Runtype, RuntypeUsageError } from './runtype'\n\n/**\n * Build a new record runtype that contains some keys from the original\n */\nexport function pick<T, K extends keyof T>(\n  original: Runtype<T>,\n  ...keys: K[]\n): Runtype<Pick<T, K>> {\n  const fields = (original as any).fields\n\n  if (!fields) {\n    throw new RuntypeUsageError(`expected a record runtype`)\n  }\n\n  const newRecordFields: any = {}\n\n  keys.forEach((k: any) => {\n    newRecordFields[k] = fields[k]\n  })\n\n  // TODO: keep 'sloppyness'\n  return record(newRecordFields) as Runtype<any>\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * A union of string literals.\n */\nexport function stringLiteralUnion<V extends string[]>(\n  ...values: V\n): Runtype<V[number]> {\n  const valuesIndex = new Set(values)\n\n  return internalRuntype((v, failOrThrow) => {\n    if (typeof v !== 'string' || !valuesIndex.has(v)) {\n      return createFail(failOrThrow, `expected one of ${values}`, v)\n    }\n\n    return v\n  }, true)\n}\n","import {\n  createFail,\n  failSymbol,\n  InternalRuntype,\n  internalRuntype,\n  isFail,\n  isPureRuntype,\n  propagateFail,\n  Runtype,\n} from './runtype'\n\nimport { arrayRuntype } from './array'\n\n// TODO: find a simple (not type-computationally expensive) generic tuple definition.\n// atm the one that comes closest would be: https://github.com/Microsoft/TypeScript/issues/13298#issuecomment-675386981\n// For now, keep the tuple definition simple as I don't see a usecase for big\n// (>5elements) tuples. Most of the time I use them only for simple [lat, lon],\n// [x,y,z] and other vectors.\n/**\n * A tuple.\n */\nexport function tuple<A>(a: Runtype<A>): Runtype<[A]>\nexport function tuple<A, B>(a: Runtype<A>, b: Runtype<B>): Runtype<[A, B]>\nexport function tuple<A, B, C>(\n  a: Runtype<A>,\n  b: Runtype<B>,\n  c: Runtype<C>,\n): Runtype<[A, B, C]>\nexport function tuple<A, B, C, D>(\n  a: Runtype<A>,\n  b: Runtype<B>,\n  c: Runtype<C>,\n  d: Runtype<D>,\n): Runtype<[A, B, C, D]>\nexport function tuple<A, B, C, D, E>(\n  a: Runtype<A>,\n  b: Runtype<B>,\n  c: Runtype<C>,\n  d: Runtype<D>,\n  e: Runtype<E>,\n): Runtype<[A, B, C, D, E]>\nexport function tuple(...types: Runtype<any>[]): Runtype<any> {\n  const isPure = types.every((t) => isPureRuntype(t))\n\n  return internalRuntype<any>((v, failOrThrow) => {\n    const a = (arrayRuntype as InternalRuntype)(v, failOrThrow)\n\n    if (isFail(a)) {\n      return propagateFail(failOrThrow, a, v)\n    }\n\n    if (a.length !== types.length) {\n      return createFail(\n        failOrThrow,\n        'tuple array does not have the required length',\n        v,\n      )\n    }\n\n    const res: any[] = isPure ? a : new Array(a.length)\n\n    for (let i = 0; i < types.length; i++) {\n      const item = (types[i] as InternalRuntype)(a[i], failSymbol)\n\n      if (isFail(item)) {\n        return propagateFail(failOrThrow, item, v, i)\n      }\n\n      if (!isPure) {\n        res[i] = item\n      }\n    }\n\n    return res\n  }, isPure)\n}\n","import { createFail, internalRuntype, Runtype } from './runtype'\n\n/**\n * undefined\n */\n// eslint-disable-next-line no-shadow-restricted-names\nfunction undefinedRuntype(): Runtype<undefined> {\n  return internalRuntype<undefined>((v, failOrThrow) => {\n    if (v !== undefined) {\n      return createFail(failOrThrow, 'expected undefined', v)\n    }\n\n    return v\n  }, true)\n}\n\nexport { undefinedRuntype as undefined }\n","import {\n  InternalRuntype,\n  internalRuntype,\n  isPureRuntype,\n  Runtype,\n} from './runtype'\n\n/**\n * Shortcut for a type or undefined.\n */\nexport function undefinedOr<A>(t: Runtype<A>): Runtype<A | undefined> {\n  const isPure = isPureRuntype(t)\n\n  return internalRuntype((v, failOrThrow) => {\n    if (v === undefined) {\n      return undefined\n    }\n\n    return (t as InternalRuntype)(v, failOrThrow)\n  }, isPure)\n}\n","import { internalRuntype, Runtype } from './runtype'\n\n/**\n * A value to check later.\n */\nexport function unknown(): Runtype<unknown> {\n  return internalRuntype((v) => {\n    return v\n  }, true)\n}\n"],"names":["debugValue","v","maxLength","s","undefined","toString","JSON","stringify","length","slice","isRuntypeErrorPath","e","Array","isArray","path","getFormattedErrorPath","formattedErrorPath","reverse","map","k","test","join","startsWith","getFormattedErrorValue","reduceRight","key","value","isResolvable","RuntypeError","reason","_this","name","_inheritsLoose","Error","RuntypeUsageError","failSymbol","Symbol","createFail","failOrThrow","msg","topLevelValue","propagateFail","failObj","push","isPureRuntypeSymbol","internalRuntype","fn","isPure","Object","assign","isPureRuntype","isFail","use","r","result","ok","error","booleanRuntype","objectRuntype","stringRuntype","integerRuntype","Number","isSafeInteger","optional","t","stringAsIntegerRuntype","parsedNumber","parseInt","n","vStringSansLeadingPlus","jsonRuntype","parse","err","String","arrayRuntype","internalRecord","typemap","sloppy","prototype","hasOwnProperty","call","isPureTypemap","typemapKeys","keys","typemapValues","values","rt","o","res","i","unknownKeys","fields","getRecordFields","record","internalDiscriminatedUnion","runtypes","typeMap","Map","forEach","tagValue","literal","set","resultingRuntype","get","every","unions","findDiscriminatingUnionKey","commonKeys","f","l","has","Set","add","possibleKeys","val","size","union","commonKey","lastFail","unionIntersection2","u","b","unionRuntypes","a","intersection2","recordA","recordB","intersection","recordIntersection2","valFromA","valFromB","arguments","options","minLength","arrayValue","item","keyRuntype","valueRuntype","getOwnPropertySymbols","keyOrFail","valueOrFail","dictionaryRuntype","enumObject","indexOf","rawPath","label","typeGuard","min","max","validationResult","lit","allowNaN","allowInfinity","isNaN","Infinity","original","newRecordFields","trim","match","valuesIndex","types"],"mappings":"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"}