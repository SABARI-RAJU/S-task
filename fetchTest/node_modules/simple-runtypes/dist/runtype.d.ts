/**
 * Thrown if the input does not match the runtype.
 *
 * Use `getFormattedErrorPath`, `getFormattedErrorValue` and
 * `getFormattedError` to convert path and value to a loggable string.
 */
export declare class RuntypeError extends Error {
    readonly path: (string | number)[];
    readonly value: any;
    readonly reason: string;
    constructor(reason: string, value: any, path: (string | number)[]);
}
/**
 * Thrown if the api is misused.
 */
export declare class RuntypeUsageError extends Error {
}
/**
 * Symbol that identifies failed typechecks
 */
export declare const failSymbol: unique symbol;
/**
 * Object to return internally if a typecheck failed
 *
 * This is used internally to avoid creating garbage for each runtype
 * validation call.
 */
export interface Fail {
    [failSymbol]: true;
    reason: string;
    path: (string | number)[];
    value?: any;
}
export declare function createFail(failOrThrow: typeof failSymbol | undefined, msg: string, topLevelValue?: unknown): any;
export declare function propagateFail(failOrThrow: typeof failSymbol | undefined, failObj: Fail, topLevelValue?: unknown, key?: string | number): Fail;
/**
 * Runtype
 *
 * Just a function. The returned value may be a copy of v, depending on the
 * runtypes implementation.
 */
export interface Runtype<T> {
    /**
     * A function to check that v 'conforms' to type T
     *
     * By default, Raises a RuntypeError if the check fails.
     * With `useRuntype(runtype, value)` it will return a `ValidationResult` instead.
     */
    (v: unknown): T;
}
/**
 * Special runtype for use in record definitions to mark optional keys.
 */
export interface OptionalRuntype<T> {
    isOptionalRuntype: true;
    (v: unknown): T;
}
export declare type Unpack<T> = T extends Runtype<infer U> ? U : T extends OptionalRuntype<infer V> ? V : never;
export declare type Collapse<T> = T extends infer U ? {
    [K in keyof U]: U[K];
} : never;
export declare const isPureRuntypeSymbol: unique symbol;
export declare function internalRuntype<T>(fn: (v: unknown, failOrThrow?: typeof failSymbol) => T, isPure?: boolean): Runtype<T>;
/**
 * A pure runtype does not change its value.
 *
 * A non-pure runtype may return a changed value.
 * This is used to get rid of redundant object copying
 */
export declare function isPureRuntype(fn: Runtype<any>): boolean;
export declare type InternalRuntype = (v: unknown, failOrThrow: typeof failSymbol | undefined) => any;
/**
 * Check whether a returned value is a failure.
 */
export declare function isFail(v: unknown): v is Fail;
