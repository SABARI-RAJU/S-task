/**
 * Turn an arbitrary object into a string of max length suitable for logging.
 */
function debugValue(v, maxLength) {
  if (maxLength === void 0) {
    maxLength = 512;
  }

  var s;

  if (v === undefined) {
    return 'undefined';
  } // `JSON.stringify(fn)` would return `undefined` thus `s.length` would become
  // `undefined.length` which would fail


  if (typeof v === 'function') {
    return v.toString();
  }

  try {
    s = JSON.stringify(v);
  } catch (_unused) {
    s = "" + v;
  }

  if (s.length > maxLength) {
    return s.slice(0, maxLength - 1) + "\u2026";
  } else {
    return s;
  }
}
/**
 * Return boolean to indicate whether passed object seems to be an RuntypeError
 */

function isRuntypeErrorPath(e) {
  return Array.isArray(e.path);
}
/**
 * Return the object path at which the error occured.
 */


function getFormattedErrorPath(e) {
  if (!isRuntypeErrorPath(e)) {
    return '(error is not a RuntypeError!)';
  } // path in Fail objects is with the root-element at the end bc. its easier
  // to build it that way (just an [].push)


  var pathInRootElementFirstOrder = [].concat(e.path).reverse();
  var formattedErrorPath = pathInRootElementFirstOrder.map(function (k) {
    return typeof k === 'number' ? "[" + k + "]" : /^\w+$/.test(k) ? "." + k : "['" + JSON.stringify(k) + "']";
  }).join('');
  return formattedErrorPath.startsWith('.') ? formattedErrorPath.slice(1) : formattedErrorPath;
}
/**
 * Return a string representaiton of the value that failed the runtype check.
 *
 * Cap the size of the returned string at maxLength
 */

function getFormattedErrorValue(e, maxLength) {
  if (maxLength === void 0) {
    maxLength = 512;
  }

  if (!isRuntypeErrorPath(e)) {
    return '(error is not a RuntypeError!)';
  }

  var _e$path$reduceRight = e.path.reduceRight(function (_ref, key) {
    var value = _ref.value,
        isResolvable = _ref.isResolvable;

    // we have not not been able to resolve the value previously - don't try any further
    if (!isResolvable) {
      return {
        value: value,
        isResolvable: isResolvable
      };
    } // try to resolve key within objects or arrays


    if (key in value) {
      return {
        value: value[key],
        isResolvable: isResolvable
      };
    } // otherwise return last value successfully resolved and mark as "not further resolvable"


    return {
      value: value,
      isResolvable: false
    };
  }, {
    value: e.value,
    isResolvable: true
  }),
      resolvedValue = _e$path$reduceRight.value;

  return debugValue(resolvedValue, maxLength);
}
/**
 * Return a string representation of the value that failed the runtype check.
 *
 * Cap the size of the returned string at maxLength
 */

function getFormattedError(e, maxLength) {
  if (maxLength === void 0) {
    maxLength = 512;
  }

  var rawPath = getFormattedErrorPath(e);
  var path = rawPath ? "<value>" + (rawPath.startsWith('[') ? '' : '.') + rawPath : '<value>';
  var label = 'name' in e ? e.name + ": " : '';
  var value = getFormattedErrorValue(e, maxLength);
  return "" + label + e.reason + " at `" + path + "` for `" + value + "`";
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/**
 * Thrown if the input does not match the runtype.
 *
 * Use `getFormattedErrorPath`, `getFormattedErrorValue` and
 * `getFormattedError` to convert path and value to a loggable string.
 */
var RuntypeError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(RuntypeError, _Error);

  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  function RuntypeError(reason, value, path) {
    var _this;

    _this = _Error.call(this, reason) || this;
    _this.name = 'RuntypeError';
    _this.reason = reason;
    _this.path = path;
    _this.value = value;
    return _this;
  }

  return RuntypeError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Thrown if the api is misused.
 */

var RuntypeUsageError = /*#__PURE__*/function (_Error2) {
  _inheritsLoose(RuntypeUsageError, _Error2);

  function RuntypeUsageError() {
    return _Error2.apply(this, arguments) || this;
  }

  return RuntypeUsageError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Symbol that identifies failed typechecks
 */

var failSymbol = /*#__PURE__*/Symbol('SimpleRuntypesFail'); // create a fail or raise the error exception if the called runtype was on top

function createFail(failOrThrow, msg, topLevelValue) {
  if (failOrThrow === undefined) {
    // runtype check failed
    throw new RuntypeError(msg, topLevelValue, []);
  } else if (failOrThrow === failSymbol) {
    var _ref;

    // runtype check failed but it should not throw an exception bc its called
    // internally e.g. as part of a union or because we want to add debug info
    // while unrolling the stack
    return _ref = {}, _ref[failSymbol] = true, _ref.reason = msg, _ref.path = [], _ref.value = undefined, _ref;
  } else {
    throw new RuntypeUsageError("failOrThrow must be undefined or the failSymbol, not " + JSON.stringify(failOrThrow));
  }
} // pass the fail up to the caller or, if on top, raise the error exception

function propagateFail(failOrThrow, failObj, topLevelValue, key) {
  if (key !== undefined) {
    failObj.path.push(key);
  }

  if (failOrThrow === undefined) {
    // runtype check failed
    throw new RuntypeError(failObj.reason, topLevelValue, failObj.path);
  } else if (failOrThrow === failSymbol) {
    return failObj;
  } else {
    throw new RuntypeUsageError("failOrThrow must be undefined or the failSymbol, not " + JSON.stringify(failOrThrow));
  }
}
var isPureRuntypeSymbol = /*#__PURE__*/Symbol('isPure'); // The internal runtype is one that receives an additional flag that
// determines whether the runtype should throw a RuntypeError or whether it
// should return a Fail up to the caller.
//
// Use this to:
//   * accumulate additional path data when unwinding a fail (propagateFail)
//   * have runtypes return a dedicated fail value to implement union over any
//     runtypes (isFail)
//
// Pass `true` as isPure to signal that this runtype is not modifying its
// value (checked with `isPureRuntype`

function internalRuntype(fn, isPure) {
  if (isPure === true) {
    return Object.assign(fn, {
      isPure: isPureRuntypeSymbol
    });
  } else if (isPure === undefined || isPure === false) {
    return fn;
  } else {
    throw new RuntypeUsageError('expected "isPure" or undefined as the second argument');
  }
}
/**
 * A pure runtype does not change its value.
 *
 * A non-pure runtype may return a changed value.
 * This is used to get rid of redundant object copying
 */

function isPureRuntype(fn) {
  return !!fn.isPure;
}
/**
 * Check whether a returned value is a failure.
 */

function isFail(v) {
  if (typeof v !== 'object' || !v) {
    return false;
  }

  return v[failSymbol];
}

/**
 * Create a validation error for custom runtypes
 */

function createError(msg) {
  return createFail(failSymbol, msg);
}
/**
 * Construct a custom runtype from a validation function.
 */

function runtype(fn) {
  return internalRuntype(function (v, failOrThrow) {
    var res = fn(v);

    if (isFail(res)) {
      return propagateFail(failOrThrow, res, v);
    }

    return res;
  });
}
/**
 * Execute a runtype but do not throw Errors
 *
 * Return a ValidationResult instead.
 * When its an Error, use `getFormattedError` on it to get a well formatted
 * message for logging or reporting.
 *
 * Useful when writing your own runtypes and when the bad performance of
 * exceptions and try-catch for error handling is of concern.
 */

function use(r, v) {
  var result = r(v, failSymbol);

  if (isFail(result)) {
    // we don't know who is using the result (passing error up the stack or
    // consuming it with e.g. `st.getFormattedError`) so set the toplevel
    // value (will be overwritten in case we're passed up anyways)
    result.value = v;
    return {
      ok: false,
      error: result
    };
  }

  return {
    ok: true,
    result: result
  };
}

/**
 * A value to check later.
 */

function any() {
  return internalRuntype(function (v) {
    return v;
  }, true);
}

var booleanRuntype = /*#__PURE__*/internalRuntype(function (v, failOrThrow) {
  if (v === true || v === false) {
    return v;
  }

  return createFail(failOrThrow, 'expected a boolean', v);
}, true);
/**
 * A boolean.
 */

function _boolean() {
  return booleanRuntype;
}

/**
 * Any value defined in the enumObject.
 */

function enumRuntype(enumObject) {
  return internalRuntype(function (v, failOrThrow) {
    // use the fast reverse lookup of number enums to check whether v is a
    // value of the enum
    if (typeof v === 'number' && enumObject[v] !== undefined) {
      return v;
    }

    if (Object.values(enumObject).indexOf(v) !== -1) {
      return v;
    }

    return createFail(failOrThrow, "expected a value that belongs to the enum " + debugValue(enumObject), v);
  }, true);
}

/**
 * null
 */
// eslint-disable-next-line no-shadow-restricted-names

function nullRuntype() {
  return internalRuntype(function (v, failOrThrow) {
    if (v !== null) {
      return createFail(failOrThrow, 'expected null', v);
    }

    return v;
  }, true);
}

/**
 * A number. By default reject NaN and Infinity values.
 *
 * Options:
 *
 *   allowNaN .. allow NaN values
 *   allowInfinity .. allow positive and negative Infinity values
 *   min .. reject numbers smaller than that
 *   max .. reject numbers larger than that
 */

function number(options) {
  var _ref = options || {},
      allowNaN = _ref.allowNaN,
      allowInfinity = _ref.allowInfinity,
      min = _ref.min,
      max = _ref.max;

  return internalRuntype(function (v, failOrThrow) {
    if (typeof v !== 'number') {
      return createFail(failOrThrow, 'expected a number', v);
    }

    if (!allowNaN && isNaN(v)) {
      return createFail(failOrThrow, 'expected a number that is not NaN', v);
    }

    if (!allowInfinity && (v === Infinity || v === -Infinity)) {
      return createFail(failOrThrow, 'expected a finite number', v);
    }

    if (min !== undefined && v < min) {
      return createFail(failOrThrow, "expected number to be >= " + min, v);
    }

    if (max !== undefined && v > max) {
      return createFail(failOrThrow, "expected number to be <= " + max, v);
    }

    return v;
  }, true);
}

var objectRuntype = /*#__PURE__*/internalRuntype(function (v, failOrThrow) {
  if (typeof v === 'object' && !Array.isArray(v) && v !== null) {
    return v;
  }

  return createFail(failOrThrow, 'expected an object', v);
}, true);
/**
 * An object that is not an array.
 */

function object() {
  return objectRuntype;
}

var stringRuntype = /*#__PURE__*/internalRuntype(function (v, failOrThrow) {
  if (typeof v === 'string') {
    return v;
  }

  return createFail(failOrThrow, 'expected a string', v);
}, true);
/**
 * A string.
 *
 * Options:
 *
 *   minLength .. reject strings that are shorter than that
 *   maxLength .. reject strings that are longer than that
 *   trim .. when true, remove leading and trailing spaces from the string
 *   match .. reject strings that do not match against provided RegExp
 */

function string(options) {
  if (!options) {
    return stringRuntype;
  }

  var minLength = options.minLength,
      maxLength = options.maxLength,
      trim = options.trim,
      match = options.match;
  var isPure = !trim; // trim modifies the string

  return internalRuntype(function (v, failOrThrow) {
    var s = stringRuntype(v, failOrThrow);

    if (isFail(s)) {
      return propagateFail(failOrThrow, s, v);
    }

    if (minLength !== undefined && s.length < minLength) {
      return createFail(failOrThrow, "expected the string length to be at least " + minLength, v);
    }

    if (maxLength !== undefined && s.length > maxLength) {
      return createFail(failOrThrow, "expected the string length to not exceed " + maxLength, v);
    }

    if (match !== undefined && !match.test(s)) {
      return createFail(failOrThrow, "expected the string to match " + match, v);
    }

    return trim ? s.trim() : s;
  }, isPure);
}

/**
 * undefined
 */
// eslint-disable-next-line no-shadow-restricted-names

function undefinedRuntype() {
  return internalRuntype(function (v, failOrThrow) {
    if (v !== undefined) {
      return createFail(failOrThrow, 'expected undefined', v);
    }

    return v;
  }, true);
}

/**
 * A value to check later.
 */

function unknown() {
  return internalRuntype(function (v) {
    return v;
  }, true);
}

function literal(lit) {
  var rt = internalRuntype(function (v, failOrThrow) {
    if (v === lit) {
      return lit;
    }

    return createFail(failOrThrow, "expected a literal: " + debugValue(lit), v);
  }, true); // keep the literal as metadata on the runtype itself to be able to use it
  // in record intersections to determine the right record runtype

  rt.literal = lit;
  return rt;
}

/**
 * A union of string literals.
 */

function stringLiteralUnion() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }

  var valuesIndex = new Set(values);
  return internalRuntype(function (v, failOrThrow) {
    if (typeof v !== 'string' || !valuesIndex.has(v)) {
      return createFail(failOrThrow, "expected one of " + values, v);
    }

    return v;
  }, true);
}

/**
 * A runtype based on a type guard
 */

function guardedBy(typeGuard) {
  return internalRuntype(function (v, failOrThrow) {
    if (!typeGuard(v)) {
      return createFail(failOrThrow, 'expected typeguard to return true', v);
    }

    return v;
  }, true);
}

/**
 * A value to ignore (typed as unknown and always set to undefined).
 */

function ignore() {
  return internalRuntype(function () {
    return undefined;
  }, true);
}

var integerRuntype = /*#__PURE__*/internalRuntype(function (v, failOrThrow) {
  if (typeof v === 'number' && Number.isSafeInteger(v)) {
    return v;
  }

  return createFail(failOrThrow, 'expected a safe integer', v);
}, true);
/**
 * A Number that is a `isSafeInteger()`
 *
 * Options:
 *
 *   min .. reject numbers smaller than that
 *   max .. reject number larger than that
 */

function integer(options) {
  if (!options) {
    return integerRuntype;
  }

  var min = options.min,
      max = options.max;
  return internalRuntype(function (v, failOrThrow) {
    var n = integerRuntype(v, failOrThrow);

    if (isFail(n)) {
      return propagateFail(failOrThrow, n, v);
    }

    if (min !== undefined && n < min) {
      return createFail(failOrThrow, "expected the integer to be >= " + min, v);
    }

    if (max !== undefined && n > max) {
      return createFail(failOrThrow, "expected the integer to be <= " + max, v);
    }

    return n;
  }, true);
}

/**
 * Shortcut for a type or null.
 */

function nullOr(t) {
  var isPure = isPureRuntype(t);
  return internalRuntype(function (v, failOrThrow) {
    if (v === null) {
      return null;
    }

    return t(v, failOrThrow);
  }, isPure);
}

/**
 * Shortcut for a type or undefined.
 */

function undefinedOr(t) {
  var isPure = isPureRuntype(t);
  return internalRuntype(function (v, failOrThrow) {
    if (v === undefined) {
      return undefined;
    }

    return t(v, failOrThrow);
  }, isPure);
}

/**
 * Optional (?), only usable within `record`
 *
 * Marks the key its used on as optional, e.g.:
 *
 *    record({foo: optional(string())})
 *
 *    => {foo?: string}
 */

function optional(t) {
  var isPure = isPureRuntype(t);
  var rt = internalRuntype(function (v, failOrThrow) {
    if (v === undefined) {
      return undefined;
    }

    return t(v, failOrThrow);
  }, isPure);
  return rt;
}

var stringAsIntegerRuntype = /*#__PURE__*/internalRuntype(function (v, failOrThrow) {
  if (typeof v === 'string') {
    var parsedNumber = parseInt(v, 10);
    var n = integerRuntype(parsedNumber, failSymbol);

    if (isFail(n)) {
      return propagateFail(failOrThrow, n, v);
    } // ensure that value did only contain that integer, nothing else
    // but also make '+1' === '1' and '-0' === '0'


    var vStringSansLeadingPlus = v === '-0' ? '0' : v[0] === '+' ? v.slice(1) : v;

    if (n.toString() !== vStringSansLeadingPlus) {
      return createFail(failOrThrow, 'expected string to contain only the safe integer, not additional characters, whitespace or leading zeros', v);
    }

    return n;
  }

  return createFail(failOrThrow, 'expected a string that contains a safe integer', v);
});
/**
 * A string that is parsed as an integer.
 *
 * Parsing is strict, e.g leading/trailing whitespace or leading zeros will
 * result in an error. Exponential notation is not allowed. The resulting
 * number must be a safe integer (`Number.isSafeInteger`).
 * A leading '+' or '-' is allowed.
 *
 * Options:
 *
 *   min .. reject numbers smaller than that
 *   max .. reject number larger than that
 */

function stringAsInteger(options) {
  if (!options) {
    return stringAsIntegerRuntype;
  }

  var min = options.min,
      max = options.max;
  return internalRuntype(function (v, failOrThrow) {
    var n = stringAsIntegerRuntype(v, failOrThrow);

    if (isFail(n)) {
      return propagateFail(failOrThrow, n, v);
    }

    if (min !== undefined && n < min) {
      return createFail(failOrThrow, "expected the integer to be >= " + min, v);
    }

    if (max !== undefined && n > max) {
      return createFail(failOrThrow, "expected the integer to be <= " + max, v);
    }

    return n;
  });
}

var jsonRuntype = /*#__PURE__*/internalRuntype(function (v, failOrThrow) {
  if (!(typeof v === 'string')) {
    return createFail(failOrThrow, 'expected a json string', v);
  }

  try {
    var jsonData = JSON.parse(v);
    return jsonData;
  } catch (err) {
    return createFail(failOrThrow, 'expected a json string: ' + String(err), v);
  }
}, false);
/**
 * A String that is valid json
 */

function json(rt) {
  return internalRuntype(function (v, failOrThrow) {
    var n = jsonRuntype(v, failOrThrow);

    if (isFail(n)) {
      return propagateFail(failOrThrow, n, v);
    }

    var validationResult = use(rt, n);

    if (!validationResult.ok) {
      return propagateFail(failOrThrow, validationResult.error, v);
    }

    return validationResult.result;
  }, false);
}

var arrayRuntype = /*#__PURE__*/internalRuntype(function (v, failOrThrow) {
  if (Array.isArray(v)) {
    return v;
  }

  return createFail(failOrThrow, "expected an Array", v);
}, true);
/**
 * An array of a given type.
 *
 * Options:
 *
 *   minLength .. reject arrays shorter than that
 *   maxLength .. reject arrays longer than that
 */

function array(a, options) {
  var _ref = options || {},
      maxLength = _ref.maxLength,
      minLength = _ref.minLength;

  var isPure = isPureRuntype(a);
  return internalRuntype(function (v, failOrThrow) {
    var arrayValue = arrayRuntype(v, failOrThrow);

    if (isFail(arrayValue)) {
      return propagateFail(failOrThrow, arrayValue, v);
    }

    if (maxLength !== undefined && arrayValue.length > maxLength) {
      return createFail(failOrThrow, "expected the array to contain at most " + maxLength + " elements", v);
    }

    if (minLength !== undefined && arrayValue.length < minLength) {
      return createFail(failOrThrow, "expected the array to contain at least " + minLength + " elements", v);
    } // copy the unknown array in case the item runtype is not pure (we do not mutate anything in place)


    var res = isPure ? arrayValue : new Array(arrayValue.length);

    for (var i = 0; i < arrayValue.length; i++) {
      var item = a(arrayValue[i], failSymbol);

      if (isFail(item)) {
        return propagateFail(failOrThrow, item, v, i);
      }

      if (!isPure) {
        res[i] = item;
      }
    }

    return res;
  }, isPure);
}

function tuple() {
  for (var _len = arguments.length, types = new Array(_len), _key = 0; _key < _len; _key++) {
    types[_key] = arguments[_key];
  }

  var isPure = types.every(function (t) {
    return isPureRuntype(t);
  });
  return internalRuntype(function (v, failOrThrow) {
    var a = arrayRuntype(v, failOrThrow);

    if (isFail(a)) {
      return propagateFail(failOrThrow, a, v);
    }

    if (a.length !== types.length) {
      return createFail(failOrThrow, 'tuple array does not have the required length', v);
    }

    var res = isPure ? a : new Array(a.length);

    for (var i = 0; i < types.length; i++) {
      var item = types[i](a[i], failSymbol);

      if (isFail(item)) {
        return propagateFail(failOrThrow, item, v, i);
      }

      if (!isPure) {
        res[i] = item;
      }
    }

    return res;
  }, isPure);
}

function isPureTypemap(typemap) {
  for (var k in typemap) {
    if (!Object.prototype.hasOwnProperty.call(typemap, k)) {
      continue;
    }

    if (!isPureRuntype(typemap[k])) {
      return false;
    }
  }

  return true;
}

function internalRecord(typemap, sloppy) {
  // a sloppy record may ignore keys and so cannot be pure
  var isPure = !sloppy && isPureTypemap(typemap); // cache typemap in arrays for a faster loop

  var typemapKeys = [].concat(Object.keys(typemap));
  var typemapValues = [].concat(Object.values(typemap));
  var rt = internalRuntype(function (v, failOrThrow) {
    // inlined object runtype for perf
    if (typeof v !== 'object' || Array.isArray(v) || v === null) {
      return createFail(failOrThrow, 'expected an object', v);
    }

    var o = v; // optimize allocations: only create a copy if the record is impure

    var res = isPure ? o : {};

    for (var i = 0; i < typemapKeys.length; i++) {
      var k = typemapKeys[i];
      var t = typemapValues[i]; // nested types should always fail with explicit `Fail` so we can add additional data

      var value = t(o[k], failSymbol);

      if (isFail(value)) {
        if (!(k in o)) {
          // rt failed because o[k] was undefined bc. the key was missing from o
          // use a more specific error message in this case
          return createFail(failOrThrow, "missing key in record: " + debugValue(k));
        }

        return propagateFail(failOrThrow, value, v, k);
      }

      if (!isPure) {
        res[k] = value;
      }
    }

    if (!sloppy) {
      var unknownKeys = [];

      for (var _k in o) {
        if (!Object.prototype.hasOwnProperty.call(typemap, _k)) {
          unknownKeys.push(o);
        }
      }

      if (unknownKeys.length) {
        return createFail(failOrThrow, "invalid keys in record " + debugValue(unknownKeys), v);
      }
    }

    return res;
  }, isPure); // fields metadata to implement combinators like (discriminated) unions,
  // pick, omit and intersection

  var fields = {};

  for (var k in typemap) {
    fields[k] = typemap[k];
  } // eslint-disable-next-line no-extra-semi
  rt.fields = fields;
  return rt;
}

function getRecordFields(r) {
  var anyRt = r;

  if (!anyRt.fields) {
    return;
  }

  return anyRt.fields;
}
/**
 * An object with defined keys and values.
 *
 * In contrast to typescript types, objects checked by this runtype will fail
 * if they have any additional keys (strict checking) not specified in
 * typemap.
 *
 * Keeps you save from unwanted propertiers and evil __proto__ injections.
 */

function record(typemap) {
  return internalRecord(typemap, false);
}
/**
 * Like record but ignore unknown keys.
 *
 * Returns a new object that only contains the keys specified in the typemap.
 * Additional keys are ignored.
 *
 * Keeps you save from unwanted propertiers and evil __proto__ injections.
 */

function sloppyRecord(typemap) {
  return internalRecord(typemap, true);
}

function dictionaryRuntype(keyRuntype, valueRuntype) {
  var isPure = isPureRuntype(keyRuntype) && isPureRuntype(valueRuntype);
  return internalRuntype(function (v, failOrThrow) {
    var o = objectRuntype(v, failOrThrow);

    if (isFail(o)) {
      return propagateFail(failOrThrow, o, v);
    }

    if (Object.getOwnPropertySymbols(o).length) {
      return createFail(failOrThrow, "invalid key in dictionary: " + debugValue(Object.getOwnPropertySymbols(o)), v);
    } // optimize allocations: only create a copy if any of the key runtypes
    // return a different object - otherwise return value as is


    var res = isPure ? o : {};

    for (var key in o) {
      if (!Object.prototype.hasOwnProperty.call(o, key)) {
        continue;
      }

      if (key === '__proto__') {
        // e.g. someone tried to sneak __proto__ into this object and that
        // will cause havoc when assigning it to a new object (in case its impure)
        return createFail(failOrThrow, "invalid key in dictionary: " + debugValue(key), v);
      }

      var keyOrFail = keyRuntype(key, failOrThrow);

      if (isFail(keyOrFail)) {
        return propagateFail(failOrThrow, keyOrFail, v);
      }

      var value = o[key];
      var valueOrFail = valueRuntype(value, failOrThrow);

      if (isFail(valueOrFail)) {
        return propagateFail(failOrThrow, valueOrFail, v);
      }

      if (!isPure) {
        res[keyOrFail] = valueOrFail;
      }
    }

    return res;
  }, isPure);
}
/**
 * An object that matches a Typecript `Record<KeyType, ValueType>` type.
 *
 * You pass a runtype for the objects keys and one for its values.
 * Keeps you save from unwanted propertiers and evil __proto__ injections.
 */


function dictionary(keyRuntype, valueRuntype) {
  return dictionaryRuntype(keyRuntype, valueRuntype);
}

// Runtypes must be created with `record(...)` which contains type metadata to
// identify the literals in each record.
// Perform an efficient lookup of runtype functions by checking the
// discriminant key and using the runtype that matches it. This results 1
// runtype check vs man in the naive union check implementation.

function internalDiscriminatedUnion(key, runtypes) {
  var typeMap = new Map(); // build an index for fast runtype lookups by literal

  runtypes.forEach(function (t) {
    var rt = t.fields[key];
    var tagValue = rt.literal;

    if (tagValue === undefined) {
      throw new RuntypeUsageError("broken record type definition, " + t + "[" + key + "] is not a literal");
    }

    if (!(typeof tagValue === 'string' || typeof tagValue === 'number')) {
      throw new RuntypeUsageError("broken record type definition, " + t + "[" + key + "] must be a string or number, not " + debugValue(tagValue));
    } // use `object` to also allow enums but they can't be used in types
    // for keys of indexes so we need any


    typeMap.set(tagValue, t);
  });
  var isPure = runtypes.every(function (t) {
    return isPureRuntype(t);
  });
  var resultingRuntype = internalRuntype(function (v, failOrThrow) {
    var o = objectRuntype(v, failOrThrow);

    if (isFail(o)) {
      return propagateFail(failOrThrow, o, v);
    }

    var tagValue = o[key];
    var rt = typeMap.get(tagValue);

    if (rt === undefined) {
      return createFail(failOrThrow, "no Runtype found for discriminated union tag " + key + ": " + debugValue(tagValue), v);
    }

    return rt(v, failOrThrow);
  }, isPure);
  resultingRuntype.unions = runtypes;
  return resultingRuntype;
} // given a list of runtypes, return the name of the key that acts as the
// unique discriminating value across all runtypes
// return undefined if no such key exists


function findDiscriminatingUnionKey(runtypes) {
  var commonKeys = new Map();

  for (var i = 0; i < runtypes.length; i++) {
    var r = runtypes[i];
    var fields = getRecordFields(r);

    if (!fields) {
      // not a record runtype -> no common tag key
      return;
    }

    for (var f in fields) {
      var fieldRuntype = fields[f];
      var l = fieldRuntype.literal;

      if (l !== undefined) {
        var _commonKeys$get;

        // found a literal value, add it to the field
        // if we get a distinct literalruntype, we can use the optimized
        // index-accessed internalDiscriminatedUnion runtype
        if (!commonKeys.has(f)) {
          commonKeys.set(f, new Set());
        }

        (_commonKeys$get = commonKeys.get(f)) === null || _commonKeys$get === void 0 ? void 0 : _commonKeys$get.add(l);
      }
    }
  }

  var possibleKeys = [];
  commonKeys.forEach(function (val, key) {
    // when the key has a unique value for each runtype it can be used as a discriminant
    if (val.size === runtypes.length) {
      possibleKeys.push(key);
    }
  });

  if (!possibleKeys.length) {
    return;
  } // just use the first key (any key in possibleKeys would suffice)


  return possibleKeys[0];
}
/**
 * A union of runtypes.
 */


function union() {
  for (var _len = arguments.length, runtypes = new Array(_len), _key = 0; _key < _len; _key++) {
    runtypes[_key] = arguments[_key];
  }

  if (!runtypes.length) {
    throw new RuntypeUsageError('no runtypes given to union');
  } // optimize: when the union is a discriminating union, find the
  // discriminating key and use it to look up the runtype for the keys value


  var commonKey = findDiscriminatingUnionKey(runtypes);

  if (commonKey !== undefined) {
    return internalDiscriminatedUnion(commonKey, runtypes);
  }

  var isPure = runtypes.every(function (t) {
    return isPureRuntype(t);
  }); // simple union validation: try all runtypes and use the first one that
  // doesn't fail

  return internalRuntype(function (v, failOrThrow) {
    var lastFail;

    for (var i = 0; i < runtypes.length; i++) {
      var val = runtypes[i](v, failSymbol);

      if (!isFail(val)) {
        return val;
      } else {
        lastFail = val;
      }
    }

    return propagateFail(failOrThrow, lastFail, v);
  }, isPure);
}

function recordIntersection2(recordA, recordB) {
  var fields = {};
  var a = recordA.fields;
  var b = recordB.fields;

  for (var k in _extends({}, a, b)) {
    if (a[k] && b[k]) {
      fields[k] = intersection(a[k], b[k]);
    } else if (a[k]) {
      fields[k] = a[k];
    } else if (b[k]) {
      fields[k] = b[k];
    } else {
      throw new RuntypeUsageError('recordIntersection2: invalid else');
    }
  } // results in a new record type


  return record(fields);
} // An intersection of a union with another type


function unionIntersection2(u, b) {
  var unionRuntypes = u.unions;

  if (!unionRuntypes || !Array.isArray(unionRuntypes) || !unionRuntypes.length) {
    throw new RuntypeUsageError('unionIntersection2: first argument is not a union type');
  } // results in a new union (because the intersection distributes over the union)


  return union.apply(void 0, unionRuntypes.map(function (a) {
    return intersection2(a, b);
  }));
}

function intersection2(a, b) {
  if ('fields' in a && 'fields' in b) {
    return recordIntersection2(a, b);
  } else if ('unions' in a && 'fields' in b) {
    return unionIntersection2(a, b);
  } else if ('unions' in b && 'fields' in a) {
    return unionIntersection2(b, a);
  } else if ('fields' in a || 'fields' in b) {
    // Does such an intersection (e.g. string | {a: number} even make sense?
    // And how would you implement it?
    throw new RuntypeUsageError('intersection2: cannot intersect a base type with a record');
  } else {
    var isPure = isPureRuntype(a) && isPureRuntype(b);
    return internalRuntype(function (v, failOrThrow) {
      var valFromA = a(v, failOrThrow);
      var valFromB = b(v, failOrThrow);

      if (isFail(valFromB)) {
        return propagateFail(failOrThrow, valFromB, v);
      }

      if (isFail(valFromA)) {
        return propagateFail(failOrThrow, valFromA, v);
      }

      return valFromB; // second runtype arg is preferred
    }, isPure);
  }
}

function intersection() {
  if (arguments.length === 2) {
    return intersection2(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1]);
  } else if (arguments.length === 3) {
    return intersection(intersection2(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1]), arguments.length <= 2 ? undefined : arguments[2]);
  } else {
    throw new RuntypeUsageError("unsupported number of arguments " + arguments.length);
  }
}

/**
 * Build a new record runtype that omits some keys from the original.
 */
// TODO: should work with unions too!!!!!

function omit(original) {
  var fields = original.fields;

  if (!fields) {
    throw new RuntypeUsageError("expected a record runtype");
  }

  var newRecordFields = _extends({}, fields);

  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  keys.forEach(function (k) {
    delete newRecordFields[k];
  }); // TODO: keep 'sloppyness'

  return record(newRecordFields);
}

/**
 * Build a new record runtype that marks all keys as optional.
 *
 * This is the runtype counterpart to `Partial<T>`.
 */

function partial(original) {
  var fields = original.fields;

  if (!fields) {
    throw new RuntypeUsageError("expected a record runtype");
  }

  var newRecordFields = {};

  for (var k in fields) {
    if (Object.prototype.hasOwnProperty.call(fields, k)) {
      // TODO: detect whether field is already optional and do not apply
      // optional a second time
      newRecordFields[k] = optional(fields[k]);
    }
  } // TODO: keep 'sloppyness'


  return record(newRecordFields);
}

/**
 * Build a new record runtype that contains some keys from the original
 */

function pick(original) {
  var fields = original.fields;

  if (!fields) {
    throw new RuntypeUsageError("expected a record runtype");
  }

  var newRecordFields = {};

  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  keys.forEach(function (k) {
    newRecordFields[k] = fields[k];
  }); // TODO: keep 'sloppyness'

  return record(newRecordFields);
}

export { RuntypeError, RuntypeUsageError, any, array, _boolean as boolean, createError, dictionary, enumRuntype as enum, getFormattedError, getFormattedErrorPath, getFormattedErrorValue, guardedBy, ignore, integer, intersection, json, literal, nullRuntype as null, nullOr, number, object, omit, optional, partial, pick, record, runtype, sloppyRecord, string, stringAsInteger, stringLiteralUnion, tuple, undefinedRuntype as undefined, undefinedOr, union, unknown, use };
//# sourceMappingURL=simple-runtypes.esm.js.map
